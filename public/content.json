{"pages":[{"title":"","text":"æ¬¢è¿æ¥åˆ°å°ç†ŠçŒ«çš„èŠ±å›­ ğŸ‘ è¿™ä¸ªæ˜¯ä¸€ä¸ªæœ‰æƒ…æ€€ä¸çˆ±å¿ƒçš„\bä¹å›­ğŸ¡\b\b\b\b\b\b\bï¼Œè®°å½•å°ç†ŠçŒ«ğŸ¼å’Œæ‹›è´¢ğŸ±ç”Ÿæ´»çš„ç‚¹ç‚¹æ»´æ»´ã€‚ å¤§å®¶æœ‰ä»€ä¹ˆå»ºè®®æˆ–å¸®åŠ©ï¼Œå¯ä»¥é€šè¿‡ä¸‹æ–¹\bå¤šç§æ–¹å¼ğŸ‘‡è”ç³»æˆ‘","link":"/about/index.html"}],"posts":[{"title":"Happy Jane's birthday! ğŸ‚","text":"æˆ‘çš„ç”Ÿæ—¥ ğŸ¼ï¼š çœ‹å–·æ³‰ â›²ï¸ï¼š çœ‹æˆ‘æ¥æ¼”å¥ ğŸ¹ï¼š æˆ‘çš„æ¢³å¦†å° ğŸŒ¹ï¼š å¼€è½¦è½¦ ğŸš—ï¼š æ’æ’åï¼Œèµ¤æœæœ ğŸï¼š","link":"/2019/06/21/Happy-Jane-s-birthday/"},{"title":"8æœˆ-9æœˆè®°å½•","text":"å–æ°´çš„æˆ‘è‡ªå¸¦éœ¸æ°” ğŸ¶ï¼š ä¸æƒ³èµ·æ¥å•Šï¼š åˆåæœ¨é©¬ ğŸ ï¼š å BUSğŸšŒï¼š","link":"/2019/09/19/8æœˆ-9æœˆè®°å½•/"},{"title":"11æœˆä¸‡åœ£èŠ‚ï½ğŸƒ","text":"éƒ½æ˜¯è§†é¢‘ ğŸ¬ï¼Œè°¨æ…ç‚¹å‡» ğŸ‘‡ï¼š æ™’å¤ªé˜³ï½ï½ ğŸŒï¼š æŒ–æŒ–æœºï¼š ä¸‡åœ£èŠ‚ï¼Œæˆ‘ä»Šå¤©èƒŒäº†ç†ŠçŒ« ğŸ¼ å“¦ï¼š ç»™çˆ·çˆ·æ‰“ç”µè¯ ğŸ“±ï¼š","link":"/2019/11/25/11æœˆä¸‡åœ£èŠ‚ï½ğŸƒ/"},{"title":"ä¸Šæ—©æ•™å’¯","text":"å¤ªé˜³å½“ç©ºç…§ èŠ±å„¿å¯¹æˆ‘ç¬‘ å°é¸Ÿè¯´æ—©æ—©æ—© ä½ ä¸ºä»€ä¹ˆèƒŒä¸Šå°ä¹¦åŒ… æˆ‘å»ä¸Šå­¦æ ¡ å¤©å¤©ä¸è¿Ÿåˆ° çˆ±å­¦ä¹ çˆ±åŠ³åŠ¨ é•¿å¤§è¦ä¸ºäººæ°‘ç«‹åŠŸåŠ³ åŠ æ²¹æˆ‘é©¬ä¸Šçˆ¬è¿‡å»äº†ï¼š ç¿»è¶Šæ»šè½®ï¼š è¹¦åºŠå¥½å¥½ç©ï¼š å†²ä¸‹æ¥å’¯ ğŸ˜Šï¼š çœŸå¥½ç© ğŸ ï¼š","link":"/2019/04/21/ä¸Šæ—©æ•™å’¯/"},{"title":"ä»Šå¤©é©¬æ€é¸¡","text":"æœ¬å®å®ä»Šå¤©ä½“éªŒ Massageï¼Œå¥½èˆ’æœå•Š ğŸ˜„ã€‚ é˜¿å§¨ä½ è½»ç‚¹ ğŸ˜‚ã€‚","link":"/2019/01/16/ä»Šå¤©é©¬æ€é¸¡/"},{"title":"åšå®¢æœ‹å‹å®¶","text":"æœ¬å®å®ä»Šå¤©åˆ° ğŸ‘¬ æœ‹å‹å®¶ ğŸ  åšå®¢ï¼Œå¥½å¼€å¿ƒ ğŸ˜„ã€‚ åè½¦è½¦ï¼š","link":"/2019/01/10/åšå®¢æœ‹å‹å®¶/"},{"title":"å‡è‚¥","text":"13 æ–¤çš„è‚¥çŒ«äº† ğŸ±ï¼Œæ˜¯æ—¶å€™å‡è‚¥äº†ï¼ï¼ï¼","link":"/2018/11/08/å‡è‚¥/"},{"title":"å…ƒå®µå¿«ä¹","text":"å¬è¯´ä»Šå¤©æˆéƒ½æ”¾çƒŸèŠ±äº† ğŸ†ã€‚ æ‹›è´¢å’Œæˆ‘æ—¥å¸¸æ‰¯çš®ï¼Œé¡ºä¾¿ç¥å¤§å®¶å…ƒå®µèŠ‚å¿«ä¹ ğŸ§¨ã€‚","link":"/2019/02/19/å…ƒå®µå¿«ä¹/"},{"title":"å‡ºé—¨æ™’å¤ªé˜³å’¯","text":"ä»Šå¤©å¤©æ°”å¥½ï¼Œå‡ºé—¨æ™’ä¸ªå¤ªé˜³ï¼ŒæŠŠå¤´å“¥ä¸å¥½å½“ï¼š å’Œå…„å¼Ÿå§å¦¹æ’æ’åï¼š å¦¹å„¿ï¼Œä½ çš„å›´å·¾è¿˜å¥½çœ‹å‘¢ï¼Œç»™æˆ‘çœ‹ä¸€å“ˆå˜›ï¼š çˆ¬å‘€çˆ¬ï¼š","link":"/2019/03/03/å‡ºé—¨æ™’å¤ªé˜³å’¯/"},{"title":"åŠ¨ç‰©å›­ğŸ’","text":"åƒå®Œé¥­å»çœ‹ ğŸµï¼š é•¿å°¾çŒ´ ğŸ™‰ï¼š é’“ä»“é¼  ğŸ¹ï¼š","link":"/2019/07/14/åŠ¨ç‰©å›­/"},{"title":"åŠªåŠ›åŠªåŠ›","text":"åŠªåŠ›å­¦ä¹ ï¼Œå¿«å¿«æˆé•¿ ğŸ’ªã€‚","link":"/2019/01/02/åŠªåŠ›åŠªåŠ›/"},{"title":"åŠå²ç…§","text":"æˆ‘çš„åŠå²ç…§ï¼ŒèŒèŒå“’ï¼š æˆ‘æœ€çˆ±çš„é¢æ¡ï¼š å¥½å¼€å¿ƒ:","link":"/2019/02/28/åŠå²ç…§/"},{"title":"åˆåƒè¾…é£Ÿäº†å•¦ğŸ˜Š","text":"ä»Šå¤©åƒèƒ¡èåœ ğŸ¥•+ ç±³ç²‰ ğŸšï¼Œè¿ç»­åƒäº† 10 å¤šå¤©èƒ¡èåœåç»ˆäºä¸æŠ—æ‹’äº†ï¼Œåšä¸ªä¸æŒ‘é£Ÿçš„ä¹–å®å®ã€‚","link":"/2019/01/06/åˆåƒè¾…é£Ÿäº†å•¦ğŸ˜Š/"},{"title":"å¬æ•…äº‹+æ™’å¤ªé˜³","text":"æ˜¥æ—¥è¿Ÿè¿Ÿï¼Œ å‰æœ¨è‹è‹ã€‚ ä»“åºšå–ˆå–ˆï¼Œ é‡‡è˜©ç¥ç¥ã€‚ æ™’å¤ªé˜³ ğŸŒï¼š çˆ¬æ¥¼æ¢¯ï¼š å¬æ•…äº‹ ğŸ“–ï¼š","link":"/2019/05/11/å¬æ•…äº‹/"},{"title":"å‘¨æœ«å¿«ä¹","text":"å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯å°ç†ŠçŒ« ğŸ˜Šï¼š åç«è½¦ï¼š çœ‹æˆ‘çˆ¬å¾—æ€ä¹ˆæ ·ï¼š ç©å…·åº—çœŸå¥½ç©ï¼š å¼€è·‘è½¦å’¯ï¼š","link":"/2019/03/16/å‘¨æœ«å¿«ä¹/"},{"title":"å‘¨æœ«é‚›å´ƒæ¸¸ç©è®°","text":"æ˜¥çœ ä¸è§‰æ™“ï¼Œå¤„å¤„é—»å•¼é¸Ÿã€‚ å¤œæ¥é£é›¨å£°ï¼ŒèŠ±è½çŸ¥å¤šå°‘ã€‚ ã€Šçˆ¸çˆ¸å»å“ªå„¿ã€‹ç¬¬ N é›† ğŸ˜„ï¼š ç‹—è›‹ JaneğŸ‘§ï¼š çƒ¤å…”è‚‰å’Œ ğŸ¥©ï¼š","link":"/2020/03/21/å‘¨æœ«é‚›å´ƒæ¸¸ç©è®°/"},{"title":"å¤–é¢çš„ä¸–ç•Œ","text":"å¤–é¢çš„ä¸–ç•Œå¾ˆç²¾å½© å¤–é¢çš„ä¸–ç•Œå¾ˆæ— å¥ˆ å½“ä½ è§‰å¾—å¤–é¢çš„ä¸–ç•Œå¾ˆç²¾å½© æˆ‘ä¼šåœ¨è¿™é‡Œè¡·å¿ƒçš„ç¥ç¦ä½ ","link":"/2019/05/31/å¤–é¢çš„ä¸–ç•Œ/"},{"title":"åœ£è¯èŠ‚å¿«åˆ°äº†å“¦ğŸ„","text":"æˆ‘å’Œåœ£è¯æ ‘ ğŸ„ï¼š æ—©æ•™è¯¾ä¸Šé¢çš„å·¥ä½œ ğŸ˜¯ï¼š æ™šä¸Šçœ‹ä½©ç¦ ğŸ·ï¼š åæ‘‡æ‘‡å’Œè½¦è½¦ ğŸš—ï¼š","link":"/2019/12/16/åœ£è¯èŠ‚å¿«åˆ°äº†å“¦ğŸ„/"},{"title":"å°ç†ŠçŒ«æ¥åˆ°è¿™ä¸ªä¸–ç•Œ","text":"å…¬å…ƒ 2018 å¹´ 6 æœˆ 21 æ—¥ï¼Œå¤è‡³ï¼Œå‡Œæ™¨ 2 ç‚¹ 08 åˆ†ï¼Œæˆéƒ½åè¥¿é™„äºŒé™¢ä¸€å£°å•¼å“­ï¼Œå°ç†ŠçŒ« ğŸ¼ æ¥åˆ°äº†è¿™ä¸ªä¸–ç•Œã€‚ ä¼¼ä¹ä¸Šå¤©çŸ¥é“ä½ å…«å­—ç¼ºæ°´ï¼Œå‡ºç”Ÿçš„æ—¶å€™çª—å¤–ä¸‹ç€æ·…æ²¥æ²¥çš„å°é›¨ã€‚ ä¼¼ä¹ä½ çŸ¥é“è‡ªå·±å«â€œå°ç†ŠçŒ«â€ï¼Œä¸€å‡ºç”Ÿå°±æ¡ç´§æ‹³å¤´ï¼Œèœ·ç€å°æ‰‹å–èŒ ğŸ˜Šã€‚ å¤©ä½¿å®å® ğŸ‘¼ï¼Œçˆ¸çˆ¸å¦ˆå¦ˆå¸Œæœ›ä½ æ°¸è¿œå¥åº·å¿«ä¹ã€‚","link":"/2018/06/21/å°ç†ŠçŒ«æ¥åˆ°ä¸–ç•Œ/"},{"title":"å¼€è¤","text":"ä»Šå¤©æ˜¯ç¥–å›½ç”Ÿæ—¥ï¼Œå°ç†ŠçŒ«ä¹Ÿè¿‡èŠ‚ï¼Œå¼€è¤äº† ğŸ˜›ã€‚","link":"/2018/10/01/å¼€è¤/"},{"title":"æˆ‘çš„äº”ä¸€èŠ‚","text":"æ¸¸æ³³ ğŸŠâ€â™€ï¸ å’¯:","link":"/2019/05/01/æˆ‘çš„äº”ä¸€èŠ‚/"},{"title":"æˆ‘åˆæ¥äº†ğŸ˜Š","text":"å’”åš“å’”åš“ ğŸ“·ï¼š çœ‹è·³èˆçš„æˆ‘ ğŸ’ƒï¼š å±±ç¾Šä½ å¥½ ğŸï¼š","link":"/2019/09/30/æˆ‘åˆæ¥äº†ğŸ˜Š/"},{"title":"æˆ‘çš„å…­ä¸€å„¿ç«¥èŠ‚ğŸˆ","text":"å…­ä¸€çš„å¤©ç©ºæ¹›è“å¦‚æ°´ï¼Œ å…­ä¸€ç”œç¾çš„æ­Œå£°ï¼Œ ä½¿æˆ‘ä»¬é‚£ä¸€é¢—é¢—æ™¶è¹å‰”é€ï¼Œ çº¯æ´æ— æ¯”çš„å¿ƒç¿¼ç¿¼çš„ç»½å¼€ï¼Œ å…­ä¸€çš„æ¢¦æ‚„æ‚„ç»½æ”¾åœ¨æˆ‘ä»¬èº«è¾¹ï¼Œ å…­ä¸€çš„ç¥ç¦æ¸©æš–æˆ‘ä»¬çš„å¿ƒç”°ï¼Œ å…­ä¸€çš„æ¬¢ç¬‘æ´‹æº¢åœ¨æˆ‘ä»¬å‘¨å›´ï¼Œ å…­ä¸€çš„æˆ‘ä»¬è¢«éœå…‰ç¬¼ç½©ï¼Œ è¿™æ˜¯å…¨ä¸–ç•Œå°æœ‹å‹çš„èŠ‚æ—¥ï¼Œ æ˜¯æ‰€æœ‰å°æœ‹å‹çƒ­ç›¼çš„èŠ‚æ—¥ï¼Œ ç¥æ‰€æœ‰å°æœ‹å‹å…­ä¸€èŠ‚å¿«ä¹ã€‚ Me &amp; Dad ğŸ‘¨â€ğŸ‘§ï¼š åšæ¸¸æˆå’¯ ğŸ¥ï¼š","link":"/2019/06/01/æˆ‘çš„å…­ä¸€å„¿ç«¥èŠ‚ğŸˆ/"},{"title":"æˆ‘çš„å‘¨å²è®°å½•ğŸï¸","text":"è¿é›¨ä¸çŸ¥æ˜¥å»ï¼Œä¸€æ™´æ–¹è§‰å¤æ·± ğŸŒ´ï¼š é˜´é˜´å¤æœ¨å•­é»„é¹‚ï¼š æ¢…å­ç•™é…¸è½¯é½¿ç‰™ï¼ŒèŠ­è•‰åˆ†ç»¿ä¸çª—çº±ï¼š","link":"/2019/07/21/æˆ‘çš„å‘¨å²è®°å½•ğŸï¸/"},{"title":"æˆ‘çš„ç¬¬ä¸€ä¸ªè¯ä¹¦","text":"ä»Šå¤©æ½œæ°´ ğŸŠâ€â™€ï¸ æˆåŠŸï¼Œè·å¾—çš„äººç”Ÿç¬¬ä¸€ä¸ªè¯ä¹¦ ğŸ˜„ã€‚","link":"/2019/01/08/æˆ‘çš„ç¬¬ä¸€ä¸ªè¯ä¹¦/"},{"title":"æ–°å¹´å¿«ä¹","text":"æ‘†ä¸ª pose ç¥å¤§å®¶çŒªå¹´å¿«ä¹ ğŸ†ï¼Œæ­å–œå‘è´¢ã€ğŸ§§ çº¢åŒ…æ‹¿æ¥ï¼ï¼ï¼","link":"/2019/02/04/æ–°å¹´å¿«ä¹/"},{"title":"æ—‹è½¬æœ¨é©¬ğŸ ","text":"æ—‹è½¬çš„æœ¨é©¬æ²¡æœ‰ç¿…è†€ ä½†å´èƒ½å¤Ÿå¸¦ç€ä½ åˆ°å¤„é£ç¿”","link":"/2019/07/01/æ—‹è½¬æœ¨é©¬/"},{"title":"æ™®å‰ğŸ–ï¸æ‚ é—²çš„å‡æœŸ","text":"å‡†å¤‡èµ·é£ ğŸ›«ï¸ï¼š å‡†å¤‡å‡ºæµ· â›µï¸ï¼š æ²™æ»©ç©è€ ğŸ–ï¸ï¼š æ™®å‰ç¾é£Ÿ ğŸœï¼š ç´¯äº†ä¸€å¤©é…’åº—ä¼‘æ¯ ğŸ›ï¸ï¼š","link":"/2020/01/07/æ™®å‰ğŸ–ï¸æ‚ é—²çš„å‡æœŸ/"},{"title":"æµ·æ´‹å…¬å›­æ¸¸è®°ğŸ¬","text":"çœ‹æµ·è±š ğŸ¬ï¼š æˆ‘æ˜¯æµ·ç›— ğŸ´â€â˜ ï¸ï¼š å’Œçƒ­å¸¦é±¼åˆå½± ğŸ ï¼š çœ‹çˆ¸çˆ¸å¦ˆå¦ˆåšé£èˆ¹ âœˆï¸","link":"/2019/10/06/æµ·æ´‹å…¬å›­æ¸¸è®°ğŸ¬/"},{"title":"çˆ¬çˆ¬å¥½ç´¯å•Š","text":"ä»¥è‡ªç„¶ä¹‹é“ï¼Œå…»è‡ªç„¶ä¹‹èº«ã€‚ è¿åŠ¨çƒ­èº« ğŸ’ªï¼š æœ¨é©¬+ç‹—ç†Šï¼š","link":"/2019/04/09/çˆ¬çˆ¬å¥½ç´¯å•Š/"},{"title":"æ‹›è´¢æ£è›‹æ—¥å¸¸","text":"æ‹›è´¢è”‘è§†ã€åƒç¿»å„¿ã€æŠ¢å¦¹å¦¹çš„åºŠç¡ã€‚","link":"/2018/11/08/æ‹›è´¢æ£è›‹æ—¥å¸¸/"},{"title":"ç‹¬è‡ªçœ‹å®¶","text":"éƒ½å›è€å®¶è¿‡å¹´äº†ï¼Œæœ¬å–µä¸€ä¸ªäººåœ¨å®¶ï¼Œæƒ³æ€ä¹ˆæ ·å°±æ€ä¹ˆæ · ğŸ˜„ã€‚ è¿˜æœ‰äººä¸Šé—¨ç»™æœåŠ¡ï¼Œä¼¸ä¸ªæ‡’è…°ï¼ŒçœŸèˆ’æœå•Šã€‚","link":"/2019/02/06/ç‹¬è‡ªçœ‹å®¶/"},{"title":"ç™¾å¤©party","text":"ä»Šå¤©å°ç†ŠçŒ«å’Œå“¥å“¥ã€å§å§ã€å¼Ÿå¼Ÿã€å¦¹å¦¹ä¸€èµ· party go ğŸ˜„ï¼š","link":"/2018/09/21/ç™¾å¤©party/"},{"title":"ç¬¬ä¸€æ¬¡å¼€è½¦è½¦ğŸï¸","text":"æˆ‘ç”¨ç¬¬ä¸€äººç§° åœ¨æ¼‚ç§»é’æ˜¥ è¾“è·Ÿèµ¢çš„åˆ†å¯¸ éƒ½è®¡ç®—å¾—å¾ˆç²¾å‡† æˆ‘è¸ä¸Šé£ç«è½® åœ¨æ¼‚ç§»é’æ˜¥ æ•…äº‹ä¸­çš„æˆ‘ä»¬ åœ¨æ¼”è‡ªå·±çš„äººç”Ÿ ä¸Šè½¦å‰é—ªä¸€å¼  ğŸ“·ğŸ˜Šï¼š ä¸Šè½¦å’¯ ğŸï¸ï¼š","link":"/2019/06/12/ç¬¬ä¸€æ¬¡å¼€è½¦è½¦ğŸï¸/"},{"title":"çˆ±åƒç™½æœ","text":"ä¸æƒ³åƒé¥­äº†ï¼š çƒçƒçœŸå¥½ç©ï¼š å¬æˆ‘åœ¨è¯´ä»€ä¹ˆï¼Ÿ æˆ‘è¦åƒé›¶é£Ÿï¼š","link":"/2019/03/21/çˆ±åƒç™½æœ/"},{"title":"2016å¾®è½¯æ¢æ˜Ÿ | Constraint Checker","text":"é¢˜ç›®æ¥æºäº 2016 å¹´å¾®è½¯æ¢æ˜Ÿå¤ä»¤è¥åœ¨çº¿æŠ€æœ¯ç¬”è¯•ï¼Œç¬”è¯•ç»“æœæ˜¯ä½œä¸ºç”„é€‰å¾®è½¯ 2016 æ ¡æ‹›æŠ€æœ¯ç±»èŒä½çš„é‡è¦å‚è€ƒä¹‹ä¸€ã€‚è¿™ä¸ªè€ƒè¯•å¯¹äºæƒ³è¿›å¾®è½¯å®ä¹ æˆ–å·¥ä½œçš„åœ¨æ ¡ç”Ÿæ¥è¯´è¿˜æ˜¯è›®é‡è¦çš„ã€‚ æœ¬äººé—²æ¥æ— èŠä¹Ÿæ³¨å†Œäº†å¸å·å°è¯•äº†ç¬¬ä¸€é¢˜ï¼Œä»£ç ç”¨ C++å®ç°ï¼Œæ¯”è¾ƒä¹±ï¼Œä¾¥å¹¸ä¸€æ¬¡é€šè¿‡ã€‚ä¸‹é¢ç›´æ¥çœ‹ä¸€ä¸‹è€ƒé¢˜ã€‚ é¢˜ç›®ï¼š æ—¶é—´é™åˆ¶:10000ms å•ç‚¹æ—¶é™:1000ms å†…å­˜é™åˆ¶:256MB æè¿° Given a set of constraints like 0&lt;N&lt;=M&lt;=100 and values for all the variables, write a checker program to determine if the constraints are satisfied. More precisely, the format of constraints is: token op token op â€¦ op token where each token is either a constant integer or a variable represented by a capital letter and each op is either less-than ( &lt; ) or less-than-or-equal-to ( &lt;= ). è¾“å…¥ The first line contains an integer N, the number of constraints. (1 â‰¤ Nâ‰¤ 20) Each of the following N lines contains a constraint in the previous mentioned format. Then follows an integer T, the number of assignments to check. (1 â‰¤ Tâ‰¤ 50) Each assignment occupies K lines where K is the number of variables in the constraints. Each line contains a capital letter and an integer, representing a variable and its value. It is guaranteed that: Every token in the constraints is either an integer from 0 to 1000000 or an variable represented by a capital letter from â€˜Aâ€™ to â€˜Zâ€™. There is no space in the constraints. In each assignment every variable appears exactly once and its value is from 0 to 1000000. è¾“å‡º For each assignment output Yes or No indicating if the constraints are satisfied. æ ·ä¾‹è¾“å…¥ 2 A&lt;B&lt;=E 3&lt;=E&lt;5 2 A 1 B 2 E 3 A 3 B 5 E 10 æ ·ä¾‹è¾“å‡º Yes No è§£é‡Šï¼š è¿™é“é¢˜é¢˜ç›®è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œå°±æ˜¯æ ¹æ®è¾“å…¥çš„è‹¥å¹²ä¸ªä¸ç­‰å¼ï¼Œæ ¡éªŒåé¢è¾“å…¥çš„æ•°æ®æ˜¯å¦éƒ½æ»¡è¶³å‰é¢çš„ä¸ç­‰å¼ï¼Œæ»¡è¶³å°±è¾“å‡º Yesï¼Œåªè¦æœ‰ä¸€ä¸ªä¸æ»¡è¶³å°±è¾“å‡º Noã€‚å¦‚â€œA&lt;B&lt;=Eï¼Œ3&lt;=E&lt;5â€è¿™ä¸ªä¸¤ä¸ªå…³ç³»å¼ï¼Œå¯¹äºè¾“å…¥ A ï¼ 1ï¼ŒB ï¼ 2ï¼ŒE ï¼ 3 è‚¯å®šæ»¡è¶³ï¼Œå› ä¸º 1&lt;2&lt;=3ï¼Œ3&lt;=3&lt;5ã€‚è€Œ A ï¼ 3, B ï¼ 5ï¼ŒE=10 å°±ä¸æ»¡è¶³ï¼Œå› ä¸º 3&lt;=10&lt;5 ä¸æˆç«‹ã€‚ åˆ†æï¼š 1ã€ç”±äºæœ‰æ‰€æœ‰ä¸ç­‰å¼éƒ½è¦é€šè¿‡æ ¡éªŒæ‰è¾“å‡º Yesï¼Œé‚£ä¹ˆä»£è¡¨æˆ‘ä»¬è¦åœ¨è¾“å…¥çš„æ—¶å€™å°±å°†æ‰€æœ‰ä¸ç­‰å¼å…³ç³»éƒ½å­˜èµ·æ¥æ–¹ä¾¿åé¢æ ¡éªŒï¼Œè¿™é‡Œæˆ‘ç”¨äº†ä¸€ä¸ª vector æ¥å­˜å‚¨è¿™äº›å…³ç³»ï¼Œåé¢æ ¡éªŒçš„æ—¶å€™éå† vector é‡Œé¢æ‰€æœ‰çš„å€¼ï¼Œä¸€ä¸ªä¸ªæ ¡éªŒã€‚ 2ã€ç”±äºæ¯ä¸ªä¸ç­‰å¼å…³ç³»åªæœ‰&quot;&lt;â€œæˆ–è€…â€&lt;=&quot;ï¼Œè¯´æ˜è¿™ä¸ªå…³ç³»æ˜¯é€’å¢çš„ï¼Œæ‰€ä»¥æˆ‘ç”¨äº† multimap&lt;intï¼Œstring&gt;æ¥å­˜å‚¨è¿™ç§å…³ç³»ï¼ˆmultimap å¯¹äº key æ˜¯è‡ªå¢é•¿æ’åºï¼Œå¹¶ä¸”å¯ä»¥å­˜å‚¨ç›¸åŒçš„ keyï¼‰ã€‚æ¥çœ‹çœ‹æˆ‘å¯¹å…³ç³»å¼çš„ä¸€ä¸ªè½¬æ¢å‡½æ•°ï¼š 123456789101112131415161718192021222324252627282930313233multimap&lt;int,string&gt; convertStrToMap(string operation){ multimap&lt;int,string&gt; mapOp; size_t len = operation.length(); int rank = 0; int prior = 0; for (int i = 0; i &lt; len; i++) { char letter = operation[i]; if (letter == &apos;&lt;&apos;) { string str = operation.substr(prior, i - prior); mapOp.insert(make_pair(rank, str)); if (i - prior == 1) { if (str[0] &gt;= &apos;A&apos; &amp;&amp; str[0] &lt;= &apos;Z&apos;) { varMap.insert(make_pair(str[0], 0)); } } prior = i + 1; rank++; } if (letter == &apos;=&apos;) { prior = i + 1; rank--; } } string str = operation.substr(prior, len - prior); mapOp.insert(make_pair(rank, str)); if (len - prior == 1) { if (str[0] &gt;= &apos;A&apos; &amp;&amp; str[0] &lt;= &apos;Z&apos;) { varMap.insert(make_pair(str[0], 0)); } } return mapOp;} è¿”å›çš„ mapOp å°±æ˜¯å°† string ç±»å‹çš„å…³ç³»å¼è½¬æ¢åçš„ multimapï¼Œè¿™é‡Œçš„ key æ˜¯ int ç±»å‹ä»£è¡¨è¯¥å˜é‡æˆ–è€…æ•°å­—æ˜¯åœ¨å…³ç³»å¼ä»€ä¹ˆå±‚çº§ï¼Œvalue æ˜¯ string ç±»å‹æ–¹ä¾¿åé¢è½¬æ¢æˆæ•°å­—è¿›è¡Œæ¯”è¾ƒã€‚ä¾‹å¦‚ï¼ŒA&lt;B&lt;=Eï¼Œåœ¨ multimap ä¸­ä¼šå­˜ä¸ºï½›0:A,1:B,1:Eï½ã€‚è¿™æ®µä»£ç è¿˜æœ‰ä¸ª varMap å˜é‡ï¼Œå®ƒæ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œç”¨æ¥è®°å½•å…³ç³»å¼ä¸­å‡ºç°çš„å˜é‡ï¼ˆé¢˜ç›®è§„å®šäº†å˜é‡åªèƒ½å¤Ÿæ˜¯ Aï¼Zï¼‰ã€‚ 3ã€æœ€åå°±æ˜¯è¾“å…¥æ•°æ®ï¼Œæ›´æ–° varMapï¼Œç„¶åæ ¹æ®å…³ç³»å¼æ¯”è¾ƒçœ‹æ˜¯å¦æ»¡è¶³ï¼Œè¾“å‡ºç»“æœã€‚ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int findValue(string input){ if (input.size() == 1 &amp;&amp; input[0] &gt;= &apos;A&apos; &amp;&amp; input[0] &lt;= &apos;Z&apos;) { return varMap[input[0]]; } return atoi(input.c_str());}void checker(vector&lt;multimap&lt;int,string&gt;&gt; opVec){ bool pass = true; for (int i = 0; i &lt; opVec.size(); i++) { multimap&lt;int,string&gt; operation = opVec[i]; multimap&lt;int,string&gt;::iterator it; int rank1 = -1, rank2 = -1; int value1, value2; string var1, var2; for (it = operation.begin(); it !=operation.end(); it++) { if (rank1 == -1) { rank1 = it-&gt;first; var1 = it-&gt;second; continue; } rank2 = it-&gt;first; var2 = it-&gt;second; value1 = findValue(var1); value2 = findValue(var2); if (rank1 == rank2) { // &lt;= if (value1 &lt;= value2) { pass = true; } else { pass = false; } } else // &lt; { if (value1 &lt; value2) { pass = true; } else { pass = false; } } if (!pass) { break; } var1 = var2; rank1 = rank2; } if (!pass) { break; } } if (pass) { cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }} ç”±äºå‰é¢å…³ç³»å¼å·²ç»æŒ‰ç»“æ„å­˜å‚¨å¥½äº†ï¼Œæ‰€ä»¥åªéœ€è¦ä¸€æ­¥æ­¥æ¯”è¾ƒæ ¡éªŒå³å¯ã€‚å±‚çº§ä¸€æ ·çš„å˜é‡ï¼Œvalue æƒ³ç­‰é€šè¿‡ï¼Œå±‚çº§ä¸ä¸€æ ·çš„ï¼Œvalue1&lt;value2 å³å¯ã€‚ çœ‹ä¸€ä¸‹åˆ¤å®šç»“æœï¼š å®Œæ•´ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//// main.cpp// Constraint Checker//// Created by Jiao Liu on 7/18/16.// Copyright Â© 2016 ChangHong. All rights reserved.//#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;map&lt;char,int&gt; varMap;multimap&lt;int,string&gt; convertStrToMap(string operation){ multimap&lt;int,string&gt; mapOp; size_t len = operation.length(); int rank = 0; int prior = 0; for (int i = 0; i &lt; len; i++) { char letter = operation[i]; if (letter == &apos;&lt;&apos;) { string str = operation.substr(prior, i - prior); mapOp.insert(make_pair(rank, str)); if (i - prior == 1) { if (str[0] &gt;= &apos;A&apos; &amp;&amp; str[0] &lt;= &apos;Z&apos;) { varMap.insert(make_pair(str[0], 0)); } } prior = i + 1; rank++; } if (letter == &apos;=&apos;) { prior = i + 1; rank--; } } string str = operation.substr(prior, len - prior); mapOp.insert(make_pair(rank, str)); if (len - prior == 1) { if (str[0] &gt;= &apos;A&apos; &amp;&amp; str[0] &lt;= &apos;Z&apos;) { varMap.insert(make_pair(str[0], 0)); } } return mapOp;}int findValue(string input){ if (input.size() == 1 &amp;&amp; input[0] &gt;= &apos;A&apos; &amp;&amp; input[0] &lt;= &apos;Z&apos;) { return varMap[input[0]]; } return atoi(input.c_str());}void checker(vector&lt;multimap&lt;int,string&gt;&gt; opVec){ bool pass = true; for (int i = 0; i &lt; opVec.size(); i++) { multimap&lt;int,string&gt; operation = opVec[i]; multimap&lt;int,string&gt;::iterator it; int rank1 = -1, rank2 = -1; int value1, value2; string var1, var2; for (it = operation.begin(); it !=operation.end(); it++) { if (rank1 == -1) { rank1 = it-&gt;first; var1 = it-&gt;second; continue; } rank2 = it-&gt;first; var2 = it-&gt;second; value1 = findValue(var1); value2 = findValue(var2); if (rank1 == rank2) { // &lt;= if (value1 &lt;= value2) { pass = true; } else { pass = false; } } else // &lt; { if (value1 &lt; value2) { pass = true; } else { pass = false; } } if (!pass) { break; } var1 = var2; rank1 = rank2; } if (!pass) { break; } } if (pass) { cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }}int main(){ int N; scanf(&quot;%d&quot;,&amp;N); vector&lt;multimap&lt;int,string&gt;&gt; opVec; while (N--) { string op; cin &gt;&gt; op; multimap&lt;int,string&gt; operation = convertStrToMap(op); opVec.push_back(operation); } int T; scanf(&quot;%d&quot;,&amp;T); while (T--) { size_t numOfVar = varMap.size(); while (numOfVar--) { char letter; int value; cin&gt;&gt;letter&gt;&gt;value; varMap[letter] = value; } checker(opVec); } return 0;}","link":"/2016/08/04/2016å¾®è½¯æ¢æ˜Ÿ-Constraint-Checker/"},{"title":"iOSå®ç°ç±»Prismaè½¯ä»¶","text":"Â¶å‰è¨€ Prisma åœ¨ 2016 ä¸Šçº¿åå°±å¤§ç«ï¼Œè¯¥ APP æ˜¯åˆ©ç”¨ç¥ç»ç½‘ç»œå’Œäººå·¥æ™ºèƒ½æŠ€æœ¯ï¼Œä¸ºæ™®é€šç…§ç‰‡åŠ å…¥è‰ºæœ¯æ•ˆæœçš„ç…§ç‰‡ç¼–è¾‘è½¯ä»¶ã€‚ åŒå¹´ Google ä¹Ÿå‘å¸ƒäº†ä¸€ç¯‡ã€ŠA LEARNED REPRESENTATION FOR ARTISTIC STYLEã€‹è®ºæ–‡ï¼Œå®ç°äº†å‰å‘è¿ç®—ä¸€æ¬¡ä¸ºç…§ç‰‡æ•´åˆå¤šç§è‰ºæœ¯é£æ ¼çš„åŠŸèƒ½ï¼Œå¹¶ä¸”ä¼˜åŒ–äº†å†…å­˜ä½¿ç”¨å’Œè¿ç®—é€Ÿåº¦ï¼Œå¯ä»¥åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šå¿«é€Ÿè¿ç®—ã€‚ æœ€è¿‘åœ¨ç ”ç©¶ Tensorflow æ•´åˆ iOS è¿‡ç¨‹ä¸­ï¼Œå‘ç° google å…¬å¼€äº†è®ºæ–‡å®ç°çš„æºç å’Œè®­ç»ƒæ•°æ®ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥é€šè¿‡è‡ªå·±å†™ä¸€ä¸ªå‰å‘è¿ç®—å›¾ï¼Œæ•´åˆå…¶è®­ç»ƒå‚æ•°å°±å¯ä»¥å¿«é€Ÿå®ç°ç±» Prisma çš„åº”ç”¨ã€‚ ä¸‹é¢å°±ä»‹ç»ä¸€ä¸‹å¦‚ä½•åœ¨ iPhone ä¸Šè·‘ä¸€ä¸ªè‡ªå·±çš„**â€œPrismaâ€**ã€‚ Â¶å‡†å¤‡å·¥ä½œ å®‰è£…Tensorflowï¼Œè¿™ä¸ªå®˜ç½‘ä¸Šæœ‰è¯¦ç»†æ•™ç¨‹è¿™é‡Œå°±ä¸å¤šè¯´äº†ã€‚ æ­å»ºiOS+Tensorflowå·¥ç¨‹ï¼Œè¿™ä¸ªå¯ä»¥æ ¹æ® Git ä¸Šçš„æ­¥éª¤å®ç°ï¼Œä¹Ÿå¯ä»¥å‚è€ƒå®˜æ–¹çš„ Demo ç¨‹åºé…ç½®ã€‚ï¼ˆè¿™ä¸ªè¿‡ç¨‹æœ‰å¾ˆå¤šå‘ï¼Œå¤šæ¬¡å°è¯•ï¼Œåº”è¯¥å¯ä»¥é…ç½®æˆåŠŸï¼‰ ä¸‹è½½æ¨¡å‹ï¼Œæœ¬æ¬¡ä½¿ç”¨çš„æ¨¡å‹æ˜¯image_stylizationï¼Œgoogle å·²å¼€æºåœ¨ GitHub ä¸Šã€‚ ä¸‹è½½è®­ç»ƒå¥½çš„å‚æ•°ï¼ŒGoogle æä¾›äº† 2 ä¸ªï¼š Monet Varied Monet è®­ç»ƒäº† 10 ç§è‰ºæœ¯å›¾ç‰‡ï¼ŒVaried è®­ç»ƒäº† 32 ç§ã€‚ å½“ç„¶ä½ ä¹Ÿå¯ä»¥è‡ªå·±è®­ç»ƒè‰ºæœ¯å›¾ç‰‡ï¼Œä½†æ˜¯å¾—ä¸‹è½½ VGG çš„è®­ç»ƒå‚æ•°å’Œ ImageNet æ•°æ®ï¼Œç„¶åè‡ªå·±è®­ç»ƒï¼Œæ¯”è¾ƒèŠ±æ—¶é—´ã€‚ Â¶æ„å»ºè®¡ç®—å›¾ è™½ç„¶ Google æä¾›äº†æ¨¡å‹çš„æºç ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰åœ¨æºç ä¸­è¾“å‡ºè¿ç®—å›¾å·²æ–¹ä¾¿è¿ç§»åˆ°ç§»åŠ¨è®¾å¤‡ä¸­ä½¿ç”¨ï¼ŒAndroid çš„ Demo ä¸­å€’æ˜¯æä¾›äº†ç”Ÿæˆçš„ pbï¼Œå¦‚ä½•è§‰å¾—è‡ªå·±å†™è®¡ç®—å›¾éº»çƒ¦å¯ä»¥ç›´æ¥æ‹·åˆ°è‡ªå·± iOS å·¥ç¨‹ä¸­ä½¿ç”¨ã€‚ æˆ‘è¿™é‡Œåˆ›å»ºäº†ä¸€ä¸ª python çš„å·¥ç¨‹ï¼Œç„¶åæŠŠ Google æºç ä¸­ model.py ç›¸å…³çš„æ–‡ä»¶éƒ½åŠ å…¥äº†å·¥ç¨‹ã€‚ æˆ‘çš„å»ºå›¾ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import numpy as npimport tensorflow as tfimport astimport osfrom tensorflow.python import pywrap_tensorflowfrom matplotlib import pyplotfrom matplotlib.pyplot import imshowimport image_utilsimport modelimport opsimport argparseimport sysnum_styles = 32imgWidth = 512imgHeight = 512channel = 3checkpoint = &quot;/Users/Jiao/Desktop/TFProject/style-image/checkpoint/multistyle-pastiche-generator-varied.ckpt&quot;inputImage = tf.placeholder(tf.float32,shape=[None,imgWidth,imgHeight,channel],name=&quot;input&quot;)styles = tf.placeholder(tf.float32,shape=[num_styles],name=&quot;style&quot;)with tf.name_scope(&quot;&quot;): transform = model.transform(inputImage, normalizer_fn=ops.weighted_instance_norm, normalizer_params={ # &apos;weights&apos;: tf.constant(mixture), &apos;weights&apos; : styles, &apos;num_categories&apos;: num_styles, &apos;center&apos;: True, &apos;scale&apos;: True})model_saver = tf.train.Saver(tf.global_variables())with tf.Session() as sess: tf.train.write_graph(sess.graph_def, &quot;/Users/Jiao/Desktop/TFProject/style-image/protobuf&quot;, &quot;input.pb&quot;) #checkpoint = os.path.expanduser(checkpoint) #if tf.gfile.IsDirectory(checkpoint): # checkpoint = tf.train.latest_checkpoint(checkpoint) # tf.logging.info(&apos;loading latest checkpoint file: {}&apos;.format(checkpoint)) #model_saver.restore(sess, checkpoint) #newstyle = np.zeros([num_styles], dtype=np.float32) #newstyle[18] = 0.5 #newstyle[17] = 0.5 #newImage = np.zeros((1,imgWidth,imgHeight,channel)) #style_image = transform.eval(feed_dict={inputImage:newImage,styles:newstyle}) #style_image = style_image[0] #imshow(style_image) #pyplot.show() è¿™é‡Œè¾“å…¥èŠ‚ç‚¹æ˜¯inputå’Œstyleï¼Œè¾“å‡ºèŠ‚ç‚¹æ˜¯ model ä¸­çš„transformer/expand/conv3/conv/Sigmoidã€‚ åˆ°æ­¤å°±å°†æ¨¡å‹çš„è®¡ç®—å›¾ä¿å­˜åˆ°äº†æœ¬åœ°æ–‡ä»¶å¤¹ä¸­ã€‚ æ¥ä¸‹æ¥å°±æ˜¯å°†å›¾å’Œ ckpt ä¸­çš„å‚æ•°åˆå¹¶ï¼Œå¹¶ä¸”ç”Ÿæˆç§»åŠ¨ç«¯çš„å¯ä»¥ä½¿ç”¨çš„ pb æ–‡ä»¶ï¼Œè¿™ä¸€æ­¥å¯ä»¥å‚è€ƒæˆ‘ä¸Šä¸€ç¯‡æ–‡ç« ã€ŠiOS+Tensorflow å®ç°å›¾åƒè¯†åˆ«ã€‹ï¼Œå¾ˆå®¹æ˜“å°±å®ç°ã€‚ Â¶iOS å·¥ç¨‹ åœ¨ä¸Šé¢å‡†å¤‡å·¥ä½œä¸­ï¼Œå¦‚æœä½ å·²ç»æŒ‰æ­¥éª¤æ­å»ºå¥½ iOS+TF çš„å·¥ç¨‹ï¼Œè¿™é‡Œä½ åªéœ€è¦å¯¼å…¥ç”Ÿæˆçš„æœ€ç»ˆ pb æ–‡ä»¶å°±è¡Œäº†ã€‚å·¥ç¨‹ç»“æ„å¦‚å›¾ï¼š ç„¶ååœ¨ iOS ä½¿ç”¨ pb æ–‡ä»¶ï¼Œæˆ‘è¿™é‡Œç›´æ¥å¯¼å…¥äº† Google æä¾›çš„tensorflow_utilsï¼Œä½¿ç”¨è¿™ä¸ªç±»é‡Œé¢çš„ LoadModel æ–¹æ³•å¯ä»¥å¾ˆå¿«çš„ç”Ÿæˆå«æœ‰è®¡ç®—å›¾çš„ sessionã€‚ 1234567891011121314- (void)viewDidLoad { [super viewDidLoad]; tensorflow::Status load_status; load_status = LoadModel(@&quot;rounded_graph&quot;, @&quot;pb&quot;, &amp;tf_session); if (!load_status.ok()) { LOG(FATAL) &lt;&lt; &quot;Couldn&apos;t load model: &quot; &lt;&lt; load_status; } currentStyle = 0; isDone = true; _styleImageView.layer.borderColor = [UIColor grayColor].CGColor; _styleImageView.layer.borderWidth = 0.5; _ogImageView.layer.borderColor = [UIColor grayColor].CGColor; _ogImageView.layer.borderWidth = 0.5;} æœ€åå°±æ˜¯è·å–å›¾ç‰‡ï¼Œæ‰§è¡Œè¿ç®—ï¼Œç”Ÿæˆè‰ºæœ¯å›¾ç‰‡å±•ç¤ºã€‚è¿™é‡Œå›¾ç‰‡éœ€è¦è½¬æ¢æˆ bitmap ç„¶åè·å– data å€¼ï¼Œå±•ç¤ºå›¾ç‰‡ä¹Ÿæ˜¯ç›¸è¯†çš„è¿‡ç¨‹ã€‚å…·ä½“ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111- (void)runCnn:(UIImage *)compressedImg{ unsigned char *pixels = [self getImagePixel:compressedImg]; int image_channels = 4; tensorflow::Tensor image_tensor( tensorflow::DT_FLOAT, tensorflow::TensorShape( {1, wanted_input_height, wanted_input_width, wanted_input_channels})); auto image_tensor_mapped = image_tensor.tensor&lt;float, 4&gt;(); tensorflow::uint8 *in = pixels; float *out = image_tensor_mapped.data(); for (int y = 0; y &lt; wanted_input_height; ++y) { float *out_row = out + (y * wanted_input_width * wanted_input_channels); for (int x = 0; x &lt; wanted_input_width; ++x) { tensorflow::uint8 *in_pixel = in + (x * wanted_input_width * image_channels) + (y * image_channels); float *out_pixel = out_row + (x * wanted_input_channels); for (int c = 0; c &lt; wanted_input_channels; ++c) { out_pixel[c] = in_pixel[c]; } } } tensorflow::Tensor style(tensorflow::DT_FLOAT, tensorflow::TensorShape({32})); float *style_data = style.tensor&lt;float, 1&gt;().data(); memset(style_data, 0, sizeof(float) * 32); style_data[currentStyle] = 1; if (tf_session.get()) { std::vector&lt;tensorflow::Tensor&gt; outputs; tensorflow::Status run_status = tf_session-&gt;Run( {{contentNode, image_tensor}, {styleNode, style}}, {outputNode}, {}, &amp;outputs); if (!run_status.ok()) { LOG(ERROR) &lt;&lt; &quot;Running model failed:&quot; &lt;&lt; run_status; isDone = true; free(pixels); } else { float *styledData = outputs[0].tensor&lt;float,4&gt;().data(); UIImage *styledImg = [self createImage:styledData]; dispatch_async(dispatch_get_main_queue(), ^{ _styleImageView.image = styledImg; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ isDone = true; free(pixels); }); }); } }}- (unsigned char *)getImagePixel:(UIImage *)image{ int width = image.size.width; int height = image.size.height; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); unsigned char *rawData = (unsigned char*) calloc(height * width * 4, sizeof(unsigned char)); NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGColorSpaceRelease(colorSpace); CGContextDrawImage(context, CGRectMake(0, 0, width, height), image.CGImage); UIImage *ogImg = [UIImage imageWithCGImage:CGBitmapContextCreateImage(context)]; dispatch_async(dispatch_get_main_queue(), ^{ _ogImageView.image = ogImg; }); CGContextRelease(context); return rawData;}- (UIImage *)createImage:(float *)pixels{ unsigned char *rawData = (unsigned char*) calloc(wanted_input_height * wanted_input_width * 4, sizeof(unsigned char)); for (int y = 0; y &lt; wanted_input_height; ++y) { unsigned char *out_row = rawData + (y * wanted_input_width * 4); for (int x = 0; x &lt; wanted_input_width; ++x) { float *in_pixel = pixels + (x * wanted_input_width * 3) + (y * 3); unsigned char *out_pixel = out_row + (x * 4); for (int c = 0; c &lt; wanted_input_channels; ++c) { out_pixel[c] = in_pixel[c] * 255; } out_pixel[3] = UINT8_MAX; } } CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * wanted_input_width; NSUInteger bitsPerComponent = 8; CGContextRef context = CGBitmapContextCreate(rawData, wanted_input_width, wanted_input_height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGColorSpaceRelease(colorSpace); UIImage *retImg = [UIImage imageWithCGImage:CGBitmapContextCreateImage(context)]; CGContextRelease(context); free(rawData); return retImg;} è¿™é‡Œè¯´æ˜ä¸€ä¸‹ï¼Œå‰é¢ python å·¥ç¨‹å·²ç»å®šä¹‰äº†ï¼Œæˆ‘çš„è¾“å…¥å’Œè¾“å‡ºå›¾ç‰‡çš„å¤§å°æ˜¯ 512âœ•512ã€‚ Â¶è¿æ¥ iPhoneï¼Œè¿è¡Œå·¥ç¨‹ æœ€åè¿ä¸Šæ‰‹æœºè¿è¡Œï¼Œå°±å¯ä»¥è‡ªå·±åˆ›å»ºè‡ªå·±çš„è‰ºæœ¯ç±»å›¾ç‰‡äº†ã€‚ğŸ˜Š æ”¾å‡ å¼ è¿è¡Œæ•ˆæœå›¾ï¼š","link":"/2017/04/28/iOSå®ç°ç±»Prismaè½¯ä»¶/"},{"title":"å¾®ä¿¡å°ç¨‹åºä¸­ç»˜åˆ¶é›·è¾¾å›¾","text":"Â¶å‰è¨€ é›·è¾¾å›¾ï¼ˆRadar Chartï¼‰ï¼Œåˆå¯ç§°ä¸ºæˆ´å¸ƒæ‹‰å›¾ã€èœ˜è››ç½‘å›¾ï¼ˆSpider Chartï¼‰ï¼Œæ˜¯è´¢åŠ¡åˆ†ææŠ¥è¡¨çš„ä¸€ç§ã€‚ä½¿ç”¨è€…èƒ½ä¸€ç›®äº†ç„¶çš„äº†è§£å„é¡¹æŒ‡æ ‡çš„å˜åŠ¨æƒ…å½¢åŠå…¶å¥½åè¶‹å‘ã€‚ æœ¬æ–‡ä»‹ç»å¦‚ä½•åœ¨å¾®ä¿¡å°ç¨‹åºä¸­å®ç°é›·è¾¾å›¾ç»˜åˆ¶ã€‚ Â¶ç»˜åˆ¶èƒŒæ™¯ é¦–å…ˆæˆ‘ä»¬éœ€è¦ç»˜åˆ¶å‡ºé›·è¾¾å›¾åé¢çš„â€œèœ˜è››ç½‘â€ã€‚å…·ä½“åŸç†å°±æ˜¯ä¸€å±‚ä¸€å±‚å°†å¤šè¾¹å½¢ç”»å‡ºæ¥ï¼Œæ ¹æ®æ•°æ®é•¿åº¦å†³å®šæ¯ä¸€ä¸ªç‚¹çš„ä½ç½®å’ŒåŠå¾„é•¿åº¦ã€‚ 123456789101112131415161718192021var angle = Math.PI * 2 / length;for (var layer = 5; layer &gt; 0; layer--) { context.beginPath(); context.setGlobalAlpha(1); context.setStrokeStyle(&quot;#D3D3D3&quot;); if (layer % 2 != 0) { context.setFillStyle(&quot;white&quot;); } else { context.setFillStyle(&quot;#F5F5F5&quot;); } var currentRad = layer / 5 * radius; context.moveTo(center.x, center.y - currentRad); var currentAngle = -Math.PI / 2; for (var i = 0; i &lt; length; i++) { context.lineTo(center.x + currentRad * Math.cos(currentAngle), center.y + currentRad * Math.sin(currentAngle)); currentAngle += angle; } context.fill(); context.closePath(); context.stroke(); } å¦‚ä»£ç æ‰€ç¤ºï¼Œangleæ˜¯æ ¹æ®æ•°æ®é•¿åº¦å†³å®šçš„ï¼Œè¿™é‡Œä¸ºäº†å¥½çœ‹ï¼Œä¸€å…±ç”»äº”å±‚ï¼Œå¹¶ä¸”äº¤æ›¿æ¶‚æŠ¹é¢œè‰²ã€‚ä¸‹å›¾æ˜¯length=6çš„æ•ˆæœï¼š Â¶ç»˜åˆ¶è½´ æ¥ä¸‹æ¥å°±æ˜¯å°†å„ä¸ªé¡¶ç‚¹ä¸åœ†å¿ƒè¿æ¥èµ·æ¥ã€‚æœ‰äº†â€œèœ˜è››ç½‘â€çš„ç»éªŒï¼Œç”»è½´å°±ç®€å•å¤šäº†ï¼Œåªéœ€è¦çŸ¥é“æœ€å¤–å±‚é¡¶ç‚¹ä½ç½®ç„¶ålineToåœ†å¿ƒå°±è¡Œäº†ã€‚ 12345678910// draw Axiscontext.beginPath();var currentAngle = -Math.PI / 2;for (var i = 0; i &lt; length; i++) { context.moveTo(center.x + radius * Math.cos(currentAngle), center.y + radius * Math.sin(currentAngle)); context.lineTo(center.x, center.y); currentAngle += angle;}context.closePath();context.stroke(); ä»¥ä¸‹æ˜¯åŠ ä¸Šè½´çº¿åçš„æ•ˆæœï¼š Â¶ç»˜åˆ¶æŒ‡æ ‡ æ¥ä¸‹æ¥æ˜¯å°†å„ä¸ªç»´åº¦æŒ‡æ ‡åå­—æ·»åŠ åˆ°å›¾è¡¨ä¸Šã€‚åŒæ•°è½´ä¸€æ ·ï¼Œé¦–å…ˆéœ€è¦ç¡®å®šæœ€å¤–å±‚é¡¶ç‚¹çš„ä½ç½®ï¼Œç„¶åæ ¹æ®ä½ç½®è°ƒæ•´æ–‡å­—æ˜¾ç¤ºçš„åŸºå‡†ï¼Œå°†æ–‡å­—å†™ä¸Šå»ã€‚ 12345678910111213141516// draw Indexcontext.beginPath();context.setFillStyle(&quot;#D3D3D3&quot;);context.setFontSize(14);var currentAngle = -Math.PI / 2;for (var i = 0; i &lt; length; i++) { var posX = center.x + radius * Math.cos(currentAngle); var posY = center.y + radius * Math.sin(currentAngle); if (posX &lt; center.x) context.setTextAlign(&quot;right&quot;); else context.setTextAlign(&quot;left&quot;); if (posY &gt; center.y) context.setTextBaseline(&quot;top&quot;); else context.setTextBaseline(&quot;bottom&quot;); context.fillText(that.options.xLabel[i], posX, posY); currentAngle += angle;}context.closePath(); è¿™é‡Œä¸ºäº†å¥½çœ‹ï¼Œå¯¹äºæ–‡å­—è¦æ˜¾ç¤ºçš„ä½ç½®å°äºä¸­å¿ƒç‚¹ x åæ ‡çš„é å³å¯¹é½ï¼Œå¦åˆ™é å·¦å¯¹é½ï¼›å¯¹äºæ–‡å­—ä½ç½®å¤§äºä¸­å¿ƒç‚¹ y åæ ‡çš„åŸºå‡†è®¾ç½®åœ¨ä¸Šæ–¹ï¼Œå¦åˆ™åœ¨ä¸‹æ–¹ã€‚ä»¥ä¸‹æ˜¯åŠ ä¸ŠæŒ‡æ ‡åçš„æ•ˆæœï¼š Â¶ç»˜åˆ¶æ•°æ® æœ€åï¼Œæˆ‘ä»¬å°†æ•°æ®ç»˜åˆ¶åˆ°å›¾è¡¨ä¸Šã€‚é¦–å…ˆï¼Œæˆ‘ä»¬è¦ç¡®å®šæ‰€æœ‰æ•°æ®çš„æœ€å¤§å€¼ï¼Œå¦‚æœæœ€å¤§å€¼å¤§äº 10ï¼Œé‚£ä¹ˆå– 10 çš„å€æ•°ã€‚ç„¶ååŒç”»â€œèœ˜è››ç½‘â€ä¸€æ ·ï¼Œå°†å„ä¸ªæ•°æ®ç‚¹çš„åŠå¾„æ ¹æ®ç›¸å¯¹äºæœ€å¤§å€¼æ¯”ä¾‹æ¢ç®—å‡ºæ¥ï¼Œç„¶åç»˜åˆ¶åœ¨å›¾è¡¨ä¸Šã€‚ 1234567891011121314151617181920212223242526272829303132// draw datavar MaxValue = Math.max.apply(null, that.options.data[0].value);that.options.data.forEach(function(val) { var temp = Math.max.apply(null, val.value); if (temp &gt; MaxValue) MaxValue = temp;});if (MaxValue &gt; 10) { MaxValue = Math.ceil(MaxValue / 10) * 10}that.options.data.forEach(function(val) { context.beginPath(); context.setStrokeStyle(val.color); var currentRad = radius * val.value[0] / MaxValue * step / MaxStep; context.moveTo(center.x, center.y - currentRad); var currentAngle = -Math.PI / 2; for (var i = 0; i &lt; length; i++) { currentRad = radius * val.value[i] / MaxValue * step / MaxStep; context.lineTo(center.x + currentRad * Math.cos(currentAngle), center.y + currentRad * Math.sin(currentAngle)); currentAngle += angle; } currentRad = radius * val.value[0] / MaxValue * step / MaxStep; context.lineTo(center.x, center.y - currentRad); context.stroke(); if (that.options.area) { context.setFillStyle(val.color); context.setGlobalAlpha(0.5); context.fill(); } context.closePath();});context.draw(); ä»¥ä¸‹å°±æ˜¯æ·»åŠ æ•°æ®åçš„å®Œæ•´æ•ˆæœï¼š Â¶æ·»åŠ ç»˜åˆ¶åŠ¨ç”» ä¸ºäº†æ˜¾ç¤ºæ•ˆæœæ›´ä½³ï¼Œæˆ‘ä»¬å¯ä»¥ç»™ç»˜åˆ¶å›¾è¡¨åŠ ä¸ŠåŠ¨ç”»ï¼Œå…·ä½“å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var angle = Math.PI * 2 / length;var step = 1;var MaxStep = that.options.animation ? 50 : 1;var animation = function() { if (step &lt;= MaxStep) { // draw background for (var layer = 5; layer &gt; 0; layer--) { context.beginPath(); context.setGlobalAlpha(1); context.setStrokeStyle(&quot;#D3D3D3&quot;); if (layer % 2 != 0) { context.setFillStyle(&quot;white&quot;); } else { context.setFillStyle(&quot;#F5F5F5&quot;); } var currentRad = layer / 5 * radius; context.moveTo(center.x, center.y - currentRad); var currentAngle = -Math.PI / 2; for (var i = 0; i &lt; length; i++) { context.lineTo(center.x + currentRad * Math.cos(currentAngle), center.y + currentRad * Math.sin(currentAngle)); currentAngle += angle; } context.fill(); context.closePath(); context.stroke(); } // draw Axis context.beginPath(); var currentAngle = -Math.PI / 2; for (var i = 0; i &lt; length; i++) { context.moveTo(center.x + radius * Math.cos(currentAngle), center.y + radius * Math.sin(currentAngle)); context.lineTo(center.x, center.y); currentAngle += angle; } context.closePath(); context.stroke(); // draw Index context.beginPath(); context.setFillStyle(&quot;#D3D3D3&quot;); context.setFontSize(14); var currentAngle = -Math.PI / 2; for (var i = 0; i &lt; length; i++) { var posX = center.x + radius * Math.cos(currentAngle); var posY = center.y + radius * Math.sin(currentAngle); if (posX &lt; center.x) context.setTextAlign(&quot;right&quot;); else context.setTextAlign(&quot;left&quot;); if (posY &gt; center.y) context.setTextBaseline(&quot;top&quot;); else context.setTextBaseline(&quot;bottom&quot;); context.fillText(that.options.xLabel[i], posX, posY); currentAngle += angle; } context.closePath(); // draw data var MaxValue = Math.max.apply(null, that.options.data[0].value); that.options.data.forEach(function(val) { var temp = Math.max.apply(null, val.value); if (temp &gt; MaxValue) MaxValue = temp; }); if (MaxValue &gt; 10) { MaxValue = Math.ceil(MaxValue / 10) * 10 } that.options.data.forEach(function(val) { context.beginPath(); context.setStrokeStyle(val.color); var currentRad = radius * val.value[0] / MaxValue * step / MaxStep; context.moveTo(center.x, center.y - currentRad); var currentAngle = -Math.PI / 2; for (var i = 0; i &lt; length; i++) { currentRad = radius * val.value[i] / MaxValue * step / MaxStep; context.lineTo(center.x + currentRad * Math.cos(currentAngle), center.y + currentRad * Math.sin(currentAngle)); currentAngle += angle; } currentRad = radius * val.value[0] / MaxValue * step / MaxStep; context.lineTo(center.x, center.y - currentRad); context.stroke(); if (that.options.area) { context.setFillStyle(val.color); context.setGlobalAlpha(0.5); context.fill(); } context.closePath(); }); context.draw(); step++; } else { clearInterval(aniName); }}var aniName = setInterval(animation, 10); æœ€ç»ˆæ•ˆæœå¦‚ä¸‹ï¼š Â¶ç»“è¯­ ğŸ˜Š ä»¥ä¸Šå°±æ˜¯åœ¨å¾®ä¿¡å°ç¨‹åºä¸­ç»˜åˆ¶é›·è¾¾å›¾çš„æ–¹æ³•ã€‚å¦‚æœ‰å…´è¶£äº†è§£æ›´å¤šï¼Œå¯ä»¥æŸ¥çœ‹å®Œæ•´ä»£ç ï¼šhttps://github.com/chmini-app/CHCharts-wechatã€‚","link":"/2018/08/29/å¾®ä¿¡å°ç¨‹åºä¸­ç»˜åˆ¶é›·è¾¾å›¾/"},{"title":"ç”¨DFSæ¥æ’åº§ä½","text":"DFSï¼ˆDepth-First-Searchï¼‰æ·±åº¦ä¼˜å…ˆç®—æ³•ï¼Œæ˜¯æœç´¢ç®—æ³•çš„ä¸€ç§ã€‚æ˜¯ä¸€ç§åœ¨å¼€å‘çˆ¬è™«æ—©æœŸä½¿ç”¨è¾ƒå¤šçš„æ–¹æ³•ã€‚å®ƒçš„æ€æƒ³æ˜¯ä»ä¸€ä¸ªé¡¶ç‚¹ V0 å¼€å§‹ï¼Œæ²¿ç€ä¸€æ¡è·¯ä¸€ç›´èµ°åˆ°åº•ï¼Œå¦‚æœå‘ç°ä¸èƒ½åˆ°è¾¾ç›®æ ‡è§£ï¼Œé‚£å°±è¿”å›åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åä»å¦ä¸€æ¡è·¯å¼€å§‹èµ°åˆ°åº•ï¼Œè¿™ç§å°½é‡å¾€æ·±å¤„èµ°çš„æ¦‚å¿µå³æ˜¯æ·±åº¦ä¼˜å…ˆçš„æ¦‚å¿µã€‚ æ·±åº¦ä¼˜å…ˆæœç´¢æ˜¯å›¾è®ºä¸­çš„ç»å…¸ç®—æ³•ï¼Œåˆ©ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•å¯ä»¥äº§ç”Ÿç›®æ ‡å›¾çš„ç›¸åº”æ‹“æ‰‘æ’åºè¡¨ï¼Œåˆ©ç”¨æ‹“æ‰‘æ’åºè¡¨å¯ä»¥æ–¹ä¾¿çš„è§£å†³å¾ˆå¤šç›¸å…³çš„å›¾è®ºé—®é¢˜ï¼Œå¦‚æœ€å¤§è·¯å¾„é—®é¢˜ç­‰ç­‰ã€‚ ä¸‹é¢ä»¥ä¸€ä¸ªå…·ä½“é—®é¢˜æ¥çœ‹ DFS çš„å®ç°ä¸å®ç”¨ã€‚ï¼ˆé—®é¢˜æ¥æº[GCJ2016-1A]BFFsï¼‰ Problem You are a teacher at the brand new Little Coders kindergarten. You haveNkids in your class, and each one has a different student ID number from 1 throughN. Every kid in your class has a single best friend forever (BFF), and you know who that BFF is for each kid. BFFs are not necessarily reciprocal â€“ that is, B being Aâ€™s BFF does not imply that A is Bâ€™s BFF. Your lesson plan for tomorrow includes an activity in which the participants must sit in a circle. You want to make the activity as successful as possible by building the largest possible circle of kids such that each kid in the circle is sitting directly next to their BFF, either to the left or to the right. Any kids not in the circle will watch the activity without participating. What is the greatest number of kids that can be in the circle? Input The first line of the input gives the number of test cases,T.Ttest cases follow. Each test case consists of two lines. The first line of a test case contains a single integerN, the total number of kids in the class. The second line of a test case containsNintegersF1,F2, â€¦,FN, whereFiis the student ID number of the BFF of the kid with student ID i. Output For each test case, output one line containing â€œCase #x: yâ€, where x is the test case number (starting from 1) and y is the maximum number of kids in the group that can be arranged in a circle such that each kid in the circle is sitting next to his or her BFF. Limits 1 â‰¤Tâ‰¤ 100. 1 â‰¤Fiâ‰¤N, for all i. Fiâ‰  i, for all i. (No kid is their own BFF.) Small dataset 3 â‰¤Nâ‰¤ 10. Large dataset 3 â‰¤Nâ‰¤ 1000. Sample Input 4 4 2 3 4 1 4 3 3 4 1 4 3 3 4 3 10 7 8 10 10 9 2 9 6 3 3 Output Case #1: 4 Case #2: 3 Case #3: 3 Case #4: 6 In sample case #4, the largest possible circle seats the following kids in the following order:7 9 3 10 4 1. (Any reflection or rotation of this circle would also work.) Note that the kid with student ID 1 is next to the kid with student ID 7, as required, because the list represents a circle. è§£é‡Šï¼š ä¸€ä¸ªå¹¼å„¿å›­ï¼Œæœ‰ N ä¸ªå°æœ‹å‹ï¼Œç¼–å·ä» 1 åˆ° Nï¼Œæ¯ä¸ªå­©å­æœ‰ä¸€ä¸ªæ°¸è¿œæœ€å¥½çš„æœ‹å‹ã€‚è¿™ä¸ª BFF ä¸æ˜¯ç›¸äº’çš„ï¼ŒA æ˜¯ B çš„ BFFï¼Œä¸ä»£è¡¨ B ä¹Ÿæ˜¯ A çš„çš„ BFFã€‚æ¥ä¸‹æ¥æ˜å¤©æœ‰èŠ‚è¯¾éœ€è¦å°æœ‹å‹åæˆä¸€ä¸ªåœˆç©æ¸¸æˆï¼Œä½†æ˜¯æ¯ä¸ªå­©å­éƒ½å¸Œæœ›è‡ªå·±çš„å·¦è¾¹æˆ–è€…å³è¾¹åçš„æ˜¯è‡ªå·±çš„ BFFï¼Œæ²¡åè¿›å»çš„å°æœ‹å‹å°±åªèƒ½è§‚çœ‹ä»–ä»¬ç©ï¼Œé‚£ä¹ˆè¿™ä¸ªåœˆæœ€å¤§èƒ½åå¤šå°‘ä¸ªå°æœ‹å‹ï¼Ÿ è¾“å…¥ç¬¬ä¸€ä¸ªæ•° T æ˜¯æµ‹è¯•æ•°æ®çš„ç»„æ•°ï¼Œç„¶åæ¯ä¸¤è¡Œä¸ºä¸€ç»„ï¼Œç¬¬ä¸€è¡Œä¸€ä¸ªæ•°å­—æ˜¯ N å°æœ‹å‹çš„ä¸ªæ•°ï¼Œç¬¬äºŒè¡Œ N ä¸ªæ•°å­—æ˜¯ç¼–å· 1 åˆ° N çš„å­©å­çš„æœ€å¥½æœ‹å‹ç¼–å·ã€‚ è¾“å‡ºæ¯è¡Œä»£è¡¨æ¯ç»„æµ‹è¯•æ•°æ®çš„æœ€å¤§åœˆåå°æœ‹å‹æ•°é‡ã€‚ åˆ†æï¼š ç¬¬ä¸€æ­¥ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°æ¯ä¸ªå­©å­é€šè¿‡ BFF è¿™ä¸ªå…³ç³»å•å‘èƒ½ä¸€å…±èƒ½é“¾åˆ°å¤šå°‘å­©å­è¿›æ¥ï¼Œè¿™é‡Œå°±è¦ç”¨åˆ° DFS æŠ€æœ¯æ¥å®ç°ã€‚æ¥çœ‹ä¸€ä¸‹ä»£ç ï¼š 12345678910111213void dfs(int *input, bool *flag ,int start, NSMutableArray *array){ if (flag[start - 1] == true) { return; } else { flag[start - 1] = true; [array addObject:[NSNumber numberWithInt:start]]; start = input[start - 1]; dfs(input, flag, start, array); }} è¿™é‡Œ input æ˜¯ BFF å…³ç³»æ•°ç»„ï¼Œflag æ˜¯æ ‡å¿—æŸä¸€ä¸ªå°å­©æ˜¯å¦è®¿é—®è¿‡çš„æ•°ç»„ï¼Œstart ä»£è¡¨ä»å“ªä¸ªå°å­©å¼€å§‹æœç´¢ï¼Œarray æ˜¯æœ€åæˆ‘ä»¬è¦çš„é“¾ã€‚ä» start ä¼ å…¥çš„å°å­©ç¼–å·å¼€å§‹æœç´¢ï¼Œå°† start è‡ªå·±å†™åˆ° array ä¸­å¹¶æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œç„¶å start æ›´æ–°ä¸ºè‡ªå·±çš„ BFFï¼Œè¿­ä»£è°ƒç”¨ dfsï¼Œç›´åˆ°èµ°åˆ°æ ‡è®°ä¸ºå·²è®¿é—®èŠ‚ç‚¹åœæ­¢æœç´¢ã€‚ç„¶åå°†åˆ†åˆ«ä» 1 åˆ° N ç¼–å·çš„å°å­©ä¸ºèµ·ç‚¹çš„å½¢æˆçš„æœ€é•¿é“¾çš„éƒ½å­˜å‚¨èµ·æ¥ã€‚è¿™é‡Œæˆ‘ä»¬å­˜åœ¨ chainArray é‡Œé¢ï¼Œæ–¹ä¾¿åé¢ä½¿ç”¨ã€‚ ç¬¬äºŒæ­¥ï¼Œæˆ‘ä»¬ç”¨åˆšæ‰ä¿å­˜çš„é“¾æ¥æ‹¼æ¥ç¯ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„æ¥è®°å½•ä»¥æ¯ä¸ªå­©å­ä¸ºèµ·ç‚¹çš„æœ€å¤§ç¯é•¿åº¦ circleï¼ŒåŒæ—¶ç”¨ä¸€ä¸ªæ•´æ•° maxNum è®°å½•æ‰€æœ‰çš„ç¯ä¸­æœ€å¤§å€¼ã€‚ç„¶åæˆ‘ä»¬å¼€å§‹éå†åˆšæ‰è®°å½•åœ¨ chainArray é‡Œé¢çš„é“¾ï¼Œè®¡ç®—ä»–ä»¬èƒ½æ‹¼æ¥æœ€é•¿ç¯çš„å¤§å°ã€‚è®¡ç®—ä¸­åˆ†ä¸‰ç§æƒ…å†µï¼š 1ã€é“¾çš„æœ€åä¸€ä½å°æœ‹å‹çš„æœ€å¥½æœ‹å‹ä¸æ˜¯ç¬¬ä¸€ä½ä¸å€’æ•°ç¬¬äºŒä½å°å­©ã€‚å¦‚ï¼š1-&gt;2-&gt;3-&gt;4ï¼Œä½†æ˜¯ 4 çš„ BFF æ˜¯ 2ï¼Œé‚£ä¹ˆè¿™ç§é“¾å°±æ˜¯æ— æ•ˆçš„ï¼Œä¹Ÿä¸èƒ½å¤Ÿæˆç¯ï¼Œé•¿åº¦å°±è®°ä¸º 0ï¼› 2ã€é“¾çš„æœ€åä¸€ä½å°æœ‹å‹çš„æœ€å¥½æœ‹å‹æ˜¯ç¬¬ä¸€ä½å°å­©ã€‚å¦‚ï¼š1-&gt;2-&gt;3-&gt;4ï¼Œ4 çš„ BFF æ˜¯ 1ï¼Œé‚£ä¹ˆè¿™ç§é“¾å°±æ˜¯è‡ªæˆç¯ï¼Œé•¿åº¦è®°ä¸ºé“¾é•¿åº¦ 4ã€‚ 3ã€é“¾çš„æœ€åä¸€ä½å°æœ‹å‹çš„æœ€å¥½æœ‹å‹æ˜¯å€’æ•°ç¬¬äºŒä½å°å­©ã€‚å¦‚ï¼š1-&gt;2-&gt;3-&gt;4ï¼Œ4 çš„ BFF æ˜¯ 3ï¼Œè¿™ç§é“¾æ—¢è‡ªæˆç¯ï¼Œåˆå¯ä»¥å’Œå…¶å®ƒä»¥ 3 ç»“å°¾çš„é“¾æ‹¼æ¥æˆç¯ï¼Œå¦‚ 5-&gt;4-&gt;3ï¼Œä¸¤ä¸ªé“¾æ‹¼æ¥åå°±æˆäº† 1-&gt;2-&gt;3&lt;-&gt;4&lt;-5ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å°±å¿…é¡»å†æ¬¡éå†æ‰€æœ‰é“¾ï¼Œæ‰¾å‡ºå’Œè¯¥é“¾æ‹¼æ¥åçš„æœ€é•¿é“¾ï¼Œè®°å½•ä¸ºä¸¤é“¾é•¿åº¦å’Œå‡ 2ï¼Œå¹¶ä¿å­˜è¿› circle ä¸­ã€‚ æœ€åï¼Œæ¯æ¬¡æ›´æ–°è¿‡åç¯é•¿åº¦è¿‡åï¼Œéœ€è¦æ›´æ–° maxNum çš„å€¼ã€‚ å®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728 for (int j = 0; j &lt; N; j++) { NSArray *array = [chainArray objectAtIndex:j]; int length = (int)array.count; int LastIndex = [[array lastObject] intValue]; int nextValue = input[LastIndex - 1]; if (nextValue != [[array firstObject] intValue] &amp;&amp; nextValue != [[array objectAtIndex:array.count - 2] intValue]) { length = 0; } else { if (nextValue == [[array objectAtIndex:array.count - 2] intValue]) { int MaxLength = 0; for (NSArray *item in chainArray) { int newLength = 0; if ([[item lastObject] intValue] == nextValue) { newLength = length + (int)[item count] - 2; } MaxLength = MAX(MaxLength, newLength); } length = MaxLength; if (circle[nextValue - 1] &lt; length) { circle[nextValue - 1] = length; } } } maxNum = MAX(maxNum, length); } è‡³æ­¤ï¼Œæˆ‘ä»¬åŸºæœ¬æ‰¾åˆ°äº†ä»¥æ‰€æœ‰å­©å­ä¸ºèµ·ç‚¹èƒ½å½¢æˆçš„å•ä¸€ç¯ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯èƒ½å½¢æˆçš„æœ€å¤§ç¯ã€‚ ç¬¬ä¸‰æ­¥ï¼Œæ‰¾å‡ºæœ€å¤§çš„ç¯å¤§å°ï¼Œä¸Šé¢çš„ maxNum å·²ç»è®°å½•äº†å•ç¯æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§å€¼ï¼Œä½†æ˜¯å¯¹äºå¦‚ 1-&gt;2-&gt;3&lt;-&gt;4&lt;-5 è¿™ç§å›ç¯ï¼Œå…¶å®è¿˜æ˜¯å¯ä»¥å’Œå…¶å®ƒå›ç¯è¿›è¡Œæ‹¼æ¥ï¼Œå¦‚å’Œ 6-&gt;7&lt;-&gt;8&lt;-9 æ‹¼æ¥ï¼Œæœ€åå¾—åˆ°æ›´å¤§çš„ç¯ 1-&gt;2-&gt;3&lt;-&gt;4&lt;-5\\6-&gt;7&lt;-&gt;8&lt;-9ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠåˆšæ‰ circle ä¸­è®°å½•çš„å›ç¯é•¿åº¦éƒ½åŠ èµ·æ¥é™¤ä»¥ 2ï¼Œå†æ¥æ›´æ–° maxNum å¾—åˆ°æœ€ç»ˆçš„ç»“æœï¼Œä»£ç å¦‚ä¸‹ï¼š 123456 int tot = 0; for (int k = 0; k &lt; N; k ++) { tot += circle[k]; } maxNum = MAX(maxNum, tot / 2); return maxNum; è‡³æ­¤ï¼Œæˆ‘ä»¬å°±å®Œç¾çš„åˆ©ç”¨ DFS å®Œæˆäº†å¯¹å°æœ‹å‹æ’åº§ä½çš„ä»»åŠ¡ã€‚ çœ‹ä¸€ä¸‹è¾“å‡ºåˆ¤å®šç»“æœï¼š Small input 16 pointsSolve C-small Judgeâ€™s response for last submission: Correct. Large input 29 pointsSolve C-large Judgeâ€™s response for last submission: Correct. å®Œæ•´ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//// main.m// BFFs//// Created by Jiao Liu on 4/16/16.// Copyright Â© 2016 ChangHong. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;void dfs(int *input, bool *flag ,int start, NSMutableArray *array){ if (flag[start - 1] == true) { return; } else { flag[start - 1] = true; [array addObject:[NSNumber numberWithInt:start]]; start = input[start - 1]; dfs(input, flag, start, array); }}long maxCircle(int *input, int N){ long maxNum = 0; NSMutableArray *chainArray = [NSMutableArray array]; int circle[N]; memset(circle, 0, sizeof(circle)); for (int i = 0; i &lt; N; i++) { bool flag[N]; memset(flag, false, sizeof(flag)); NSMutableArray *array = [NSMutableArray array]; dfs(input, flag, i + 1, array); [chainArray addObject:array]; } for (int j = 0; j &lt; N; j++) { NSArray *array = [chainArray objectAtIndex:j]; int length = (int)array.count; int LastIndex = [[array lastObject] intValue]; int nextValue = input[LastIndex - 1]; if (nextValue != [[array firstObject] intValue] &amp;&amp; nextValue != [[array objectAtIndex:array.count - 2] intValue]) { length = 0; } else { if (nextValue == [[array objectAtIndex:array.count - 2] intValue]) { int MaxLength = 0; for (NSArray *item in chainArray) { int newLength = 0; if ([[item lastObject] intValue] == nextValue) { newLength = length + (int)[item count] - 2; } MaxLength = MAX(MaxLength, newLength); } length = MaxLength; if (circle[nextValue - 1] &lt; length) { circle[nextValue - 1] = length; } } } maxNum = MAX(maxNum, length); } int tot = 0; for (int k = 0; k &lt; N; k ++) { tot += circle[k]; } maxNum = MAX(maxNum, tot / 2); return maxNum;}int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... freopen(&quot;/Users/Jiao/Desktop/CodeJam/BFFs/C-large-practice.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;/Users/Jiao/Desktop/CodeJam/BFFs/C-large-practice.out&quot;, &quot;w&quot;, stdout); int T; scanf(&quot;%d&quot;,&amp;T); for (int i = 1; i&lt;=T; i++) { int N; scanf(&quot;%d&quot;,&amp;N); int Bffs[N]; for (int j = 0; j&lt;N; j++) { int bestFriend; scanf(&quot;%d&quot;,&amp;bestFriend); Bffs[j]=bestFriend; } printf(&quot;Case #%d: %ld\\n&quot;,i,maxCircle(Bffs,N)); } } return 0;}","link":"/2016/08/02/ç”¨DFSæ¥æ’åº§ä½/"},{"title":"å‰–æã€OCã€‘ä¸­æ·±å¤åˆ¶ä¸æµ…å¤åˆ¶","text":"åœ¨ OC ç¼–ç¨‹ä¸­ï¼Œå¸¸å¸¸ä¼šç”¨åˆ°å¯¹å¯¹è±¡çš„å¤åˆ¶ï¼Œç„¶åæ“ä½œå‰¯æœ¬å¯¹è±¡ã€‚ç„¶è€Œå¯¹ä¸åº”è¯¥é€‰æ‹©ä½•ç§å¯¹è±¡å¤åˆ¶çš„æ–¹å¼ï¼Œå¤åˆ¶åå‰¯æœ¬å¯¹è±¡æ“ä½œä¼šä¸ä¼šå½±å“åŸå§‹å¯¹è±¡ç­‰é—®é¢˜ï¼Œæˆ‘ä»¬å¾€å¾€æ²¡æœ‰è¿‡å¤šè€ƒè™‘ï¼Œè€Œæ˜¯å‡­å€Ÿç»éªŒåœ¨ç¼–ç ã€‚æ¥ä¸‹æ¥å°±å¯¹ OC ä¸­å¯¹è±¡å¤åˆ¶æœºåˆ¶è¿›è¡Œå‰–æï¼Œé€šè¿‡å¯¹å¤åˆ¶æœºåˆ¶çš„ç ”ç©¶å¯ä»¥åœ¨ç¼–ç ä¸­å¯¹å¯¹è±¡çš„å¤åˆ¶æ›´åŠ æ¸¸åˆƒæœ‰ä½™ã€‚ é¦–å…ˆï¼Œåœ¨ OC ä¸­å¤åˆ¶åˆ†ä¸ºæ·±å¤åˆ¶ä¸æµ…å¤åˆ¶ï¼Œä¸€ä¸ªæ¯”è¾ƒè®¤å¯çš„å®šä¹‰æ˜¯ï¼š **æ·±å¤åˆ¶ï¼š**å¤åˆ¶å¯¹è±¡å¼•ç”¨ä¸å¯¹è±¡æœ¬èº«ã€‚ **æµ…å¤åˆ¶ï¼š**åªå¤åˆ¶å¯¹è±¡å¼•ç”¨ã€‚ é‚£ä¹ˆå“ªäº›æ“ä½œæ‰æ˜¯æµ…å¤åˆ¶ï¼Œå“ªäº›æ“ä½œæ˜¯æ·±å¤åˆ¶ï¼Ÿ æ‰€æœ‰çš„å¯¹è±¡é—´èµ‹å€¼æ“ä½œéƒ½æ˜¯æµ…å¤åˆ¶ï¼Œä»…ä»…å¤åˆ¶äº†å¼•ç”¨ã€‚å¦‚ CopyStr = Str1ï¼Œè¿™é‡Œ CopyStr å’Œ Str1 æŒ‡å‘çš„åŒä¸€å†…å­˜åœ°å€ï¼Œæ”¹å˜ä¸¤è€…ä¹‹é—´ä»»ä½•ä¸€ä¸ªå€¼ï¼Œå¦ä¸€ä¸ªéƒ½ä¼šéšä¹‹æ”¹å˜ã€‚ è¯•ä¾‹ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738void assignTest(){ printf(&quot;-----Assign Test-----\\n\\n&quot;); NSString *str1 = @&quot;Hello&quot;; NSString *str2 = str1; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str2 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str2); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str2); printf(&quot;\\n&quot;); NSMutableString *str3 = [NSMutableString stringWithString:@&quot;Hello&quot;]; NSMutableString *str4 = str3; [str3 appendString:@&quot; World&quot;]; [str4 appendString:@&quot;!&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str3 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str4 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str3); printf(&quot;copyStr value address: %p\\n&quot;,str4); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str3); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str4); printf(&quot;\\n&quot;); NSMutableArray *arr1 = [NSMutableArray arrayWithObjects:@&quot;Hello&quot;, nil]; NSMutableArray *arr2 = arr1; [arr1 addObject:@&quot;World&quot;]; [arr2 addObject:@&quot;!&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr2); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr2); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr2); printf(&quot;\\n&quot;);} è¾“å‡ºç»“æœï¼š -----Assign Test----- orignalStr : Hello copyStr : Hello orignalStr value address: 0x100002060 copyStr value address: 0x100002060 orignalStr pointer address: 0x7fff5fbff7a8 copyStr pointer address: 0x7fff5fbff7a0 orignalStr : Hello World! copyStr : Hello World! orignalStr value address: 0x1002005c0 copyStr value address: 0x1002005c0 orignalStr pointer address: 0x7fff5fbff798 copyStr pointer address: 0x7fff5fbff790 2016-08-22 11:35:20.312 CopyDemo[2046:72936] orignalArray : ( ** Hello,** ** World,** ** â€œ!â€** ) 2016-08-22 11:35:20.313 CopyDemo[2046:72936] copyArray : ( ** Hello,** ** World,** ** â€œ!â€** ) orignalArray value address: 0x100406910 copyArray value address: 0x100406910 orignalArray pointer address: 0x7fff5fbff788 copyArray pointer address: 0x7fff5fbff780 é€šè¿‡ä¸Šé¢ç»“æœæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvalue çš„åœ°å€éƒ½æ˜¯ä¸€æ ·çš„ï¼Œè€Œ pointer çš„åœ°å€æ˜¯ä¸ä¸€æ ·çš„ï¼Œè¿™å°±è¯´æ˜äº†èµ‹å€¼æ“ä½œæ˜¯æµ…å¤åˆ¶ï¼Œåªæ˜¯ç”Ÿæˆä¸¤ä»½å¯¹è±¡çš„å¼•ç”¨ï¼Œè€Œå¯¹è±¡æœ¬èº«è¿˜æ˜¯åŒä¸€ä»½ã€‚åŸå¯¹è±¡å€¼å’Œå‰¯æœ¬å¯¹è±¡çš„å€¼æ“ä½œæ˜¯ç›¸äº’å½±å“çš„ã€‚ **é‚£ä¹ˆ OC ä¸­å¦‚ä½•å®ç°æ·±å¤åˆ¶å‘¢ï¼Ÿ ** OC ä¸­æ·±å¤åˆ¶æ˜¯é€šè¿‡ copy ä¸ mutableCopy æ–¹æ³•å®ç°ï¼ˆä½†ä¸æ˜¯éƒ½èƒ½è¾¾åˆ°æ·±å¤åˆ¶çš„ç›®çš„ï¼‰ï¼Œé€šè¿‡ copy å¤åˆ¶åçš„å‰¯æœ¬éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œé€šè¿‡ mutableCopy å¤åˆ¶åçš„å‰¯æœ¬éƒ½æ˜¯å¯å˜çš„ã€‚å¦‚åˆå§‹å¯¹è±¡ä¸º NSString ä¸ NSMutableStringï¼Œé€šè¿‡ copy åå‰¯æœ¬éƒ½æ˜¯ NSStringï¼Œè€Œé€šè¿‡ mutableCopy åéƒ½æ˜¯ NSMutableStringã€‚ æ¥ä¸‹æ¥åˆ†ä¸¤ç§æƒ…å†µè®¨è®º copy ä¸ mutableCopyï¼š åˆå§‹å¯¹è±¡ä¸å¯å˜ï¼ˆå¦‚ NSStringã€NSArray ç­‰ï¼‰ è°ƒç”¨ copy æ–¹æ³•ä¹Ÿæ˜¯æµ…å¤åˆ¶ï¼Œç­‰åŒäºç›´æ¥èµ‹å€¼ï¼Œå› ä¸ºå¤åˆ¶è¿‡åçš„å‰¯æœ¬å’ŒåŸæ¥çš„å¯¹è±¡éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œæ‰€ä»¥è°ƒç”¨ copy æœ¬è´¨å°±æ˜¯èµ‹å€¼æ“ä½œï¼Œå¤åˆ¶äº†å¼•ç”¨ï¼Œä½†æ˜¯éƒ½æŒ‡å‘åŒä¸€å†…å­˜åœ°å€ã€‚ è°ƒç”¨ mutableCopy æ˜¯æ·±å¤åˆ¶ï¼Œå‰¯æœ¬æˆä¸ºäº†å¯å˜å¯¹è±¡ï¼Œä½†æ˜¯æ“ä½œå‰¯æœ¬ï¼Œå¯¹åˆå§‹å¯¹è±¡çš„å€¼ä¸ä¼šäº§ç”Ÿå½±å“ã€‚ è¯•ä¾‹ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void constCopyTest(){ printf(&quot;-----ConstCopy Test-----\\n\\n&quot;); printf(&quot;-NSString Copy-\\n&quot;); NSString *str1 = @&quot;Hello&quot;; NSString *str2 = [str1 copy]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str2 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str2); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str2); printf(&quot;\\n&quot;); NSMutableString *str3 = [str1 mutableCopy]; [str3 appendString:@&quot; World!&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str3 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str3); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str3); printf(&quot;\\n&quot;); printf(&quot;-NSArray Copy-\\n&quot;); NSArray *arr1 = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&quot;Hello&quot;], nil]; NSArray *arr2 = [arr1 copy]; [[arr1 objectAtIndex:0] appendString:@&quot; World!&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr2); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr2); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr2); printf(&quot;\\n&quot;); NSMutableArray *arr3 = [arr1 mutableCopy]; [arr3 addObject:@&quot;World&quot;]; [[arr1 objectAtIndex:0] appendString:@&quot; + str1&quot;]; [[arr3 objectAtIndex:0] appendString:@&quot; + str3&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr3); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr3); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr3); printf(&quot;\\n&quot;);} è¾“å‡ºç»“æœï¼š -----ConstCopy Test----- -NSString Copy- orignalStr : Hello copyStr : Hello orignalStr value address: 0x100002060 copyStr value address: 0x100002060 orignalStr pointer address: 0x7fff5fbff7a8 copyStr pointer address: 0x7fff5fbff7a0 orignalStr : Hello copyStr : Hello World! orignalStr value address: 0x100002060 copyStr value address: 0x1004074d0 orignalStr pointer address: 0x7fff5fbff7a8 copyStr pointer address: 0x7fff5fbff798 -NSArray Copy- 2016-08-22 11:35:20.314 CopyDemo[2046:72936] orignalArray : ( ** â€œHello World!â€** ) 2016-08-22 11:35:20.314 CopyDemo[2046:72936] copyArray : ( ** â€œHello World!â€** ) orignalArray value address: 0x1001016b0 copyArray value address: 0x1001016b0 orignalArray pointer address: 0x7fff5fbff790 copyArray pointer address: 0x7fff5fbff788 2016-08-22 11:35:20.314 CopyDemo[2046:72936] orignalArray : ( ** â€œHello World! + str1 + str3â€** ) 2016-08-22 11:35:20.314 CopyDemo[2046:72936] copyArray : ( ** â€œHello World! + str1 + str3â€,** ** World** ) orignalArray value address: 0x1001016b0 copyArray value address: 0x100300000 orignalArray pointer address: 0x7fff5fbff790 copyArray pointer address: 0x7fff5fbff780 è¾“å‡ºç»“æœå¯ä»¥çœ‹åˆ°ï¼Œé€šè¿‡ copy æ–¹æ³•å¤åˆ¶åçš„å‰¯æœ¬å¯¹è±¡çš„ value åœ°å€å’ŒåŸå¯¹è±¡æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥é’ˆå¯¹ä¸å¯å˜å¯¹è±¡æ˜¯ç”¨ copy æ–¹æ³•æ˜¯æµ…å¤åˆ¶ã€‚è€Œ mutableCopy æ–¹æ³•å¤åˆ¶åï¼Œå‰¯æœ¬å¯¹è±¡çš„ value å’Œ pointer åœ°å€éƒ½å’ŒåŸå¯¹è±¡ä¸ä¸€æ ·äº†ï¼Œè¯´æ˜ mutableCopy æ–¹æ³•æ˜¯æ·±å¤åˆ¶ã€‚ åˆå§‹å¯¹è±¡å¯å˜ï¼ˆå¦‚ NSMutableStringã€NSMutableArray ç­‰ï¼‰ è°ƒç”¨ copy æ–¹æ³•æ˜¯æ·±å¤åˆ¶ï¼Œå› ä¸ºè¿™é‡Œå‰¯æœ¬æ˜¯ä¸å¯å˜çš„ï¼Œæ‰€ä»¥åªè€ƒè™‘åˆå§‹å¯¹è±¡æ”¹å˜ã€‚å› ä¸ºæ˜¯æ·±å¤åˆ¶ï¼Œåˆå§‹å¯¹è±¡æ— è®ºæ€ä¹ˆæ”¹å˜ï¼Œå‰¯æœ¬çš„å€¼éƒ½æ˜¯ä¸å˜çš„ã€‚ è°ƒç”¨ mutableCopy ä¹Ÿæ˜¯æ·±å¤åˆ¶ï¼Œå¤åˆ¶è¿‡åï¼Œå‰¯æœ¬ä¸åˆå§‹å¯¹è±¡ä¹‹é—´çš„æ”¹å˜éƒ½æ˜¯ç‹¬ç«‹ä¸å½±å“çš„ï¼Œå¦‚åˆå§‹å¯¹è±¡ str = â€œexampleâ€ï¼Œstr+â€ append1â€ï¼Œå‰¯æœ¬ str+â€ append2â€ï¼Œæœ€ç»ˆè¾“å‡ºç»“æœä¼šæ˜¯åˆå§‹å¯¹è±¡ä¸ºâ€example append1â€ï¼Œå‰¯æœ¬ä¸ºâ€example append2â€ã€‚ è¯•ä¾‹ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void mutableCopyTest(){ printf(&quot;-----MutableCopy Test-----\\n\\n&quot;); printf(&quot;-NSString Copy-\\n&quot;); NSMutableString *str1 = [NSMutableString stringWithString:@&quot;Hello&quot;]; NSString *str2 = [str1 copy]; [str1 appendString:@&quot; World&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str2 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str2); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str2); printf(&quot;\\n&quot;); NSMutableString *str3 = [str1 mutableCopy]; [str1 appendString:@&quot; + str1&quot;]; [str3 appendString:@&quot; + str3&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str3 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str3); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str3); printf(&quot;\\n&quot;); printf(&quot;-NSArray Copy-\\n&quot;); NSMutableArray *arr1 = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;Hello&quot;], nil]; NSArray *arr2 = [arr1 copy]; [[arr1 objectAtIndex:0] appendString:@&quot; World!&quot;]; [arr1 addObject:@&quot;Word&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr2); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr2); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr2); printf(&quot;\\n&quot;); NSMutableArray *arr3 = [arr1 mutableCopy]; [arr1 addObject:@&quot;+arr1&quot;]; [arr3 addObject:@&quot;+arr3&quot;]; [[arr1 objectAtIndex:0] appendString:@&quot; + str1&quot;]; [[arr3 objectAtIndex:0] appendString:@&quot; + str3&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr3); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr3); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr3); printf(&quot;\\n&quot;);} è¾“å‡ºç»“æœï¼š -----MutableCopy Test----- -NSString Copy- orignalStr : Hello World copyStr : Hello orignalStr value address: 0x100300080 copyStr value address: 0x6f6c6c654855 orignalStr pointer address: 0x7fff5fbff7a8 copyStr pointer address: 0x7fff5fbff7a0 orignalStr : Hello World + str1 copyStr : Hello World + str3 orignalStr value address: 0x100300080 copyStr value address: 0x100300320 orignalStr pointer address: 0x7fff5fbff7a8 copyStr pointer address: 0x7fff5fbff798 -NSArray Copy- 2016-08-22 11:35:20.314 CopyDemo[2046:72936] orignalArray : ( ** â€œHello World!â€,** ** Word** ) 2016-08-22 11:35:20.314 CopyDemo[2046:72936] copyArray : ( ** â€œHello World!â€** ) orignalArray value address: 0x100300000 copyArray value address: 0x100300b00 orignalArray pointer address: 0x7fff5fbff790 copyArray pointer address: 0x7fff5fbff788 2016-08-22 11:35:20.314 CopyDemo[2046:72936] orignalArray : ( ** â€œHello World! + str1 + str3â€,** ** Word,** ** â€œ+arr1â€** ) 2016-08-22 11:35:20.314 CopyDemo[2046:72936] copyArray : ( ** â€œHello World! + str1 + str3â€,** ** Word,** ** â€œ+arr3â€** ) orignalArray value address: 0x100300000 copyArray value address: 0x100300e40 orignalArray pointer address: 0x7fff5fbff790 copyArray pointer address: 0x7fff5fbff780 é€šè¿‡è¾“å‡ºç»“æœå¯ä»¥çœ‹åˆ°ï¼Œå¯¹äºå¯å˜å¯¹è±¡ï¼Œè°ƒç”¨ copy ä¸ mutableCopy æ–¹æ³•éƒ½æ˜¯æ·±å¤åˆ¶ï¼Œå› ä¸ºå‰¯æœ¬çš„ value å’Œ pointer åœ°å€éƒ½ä¸åŸå¯¹è±¡ä¸åŒã€‚ æ³¨ï¼šå¯¹äºç½‘ä¸ŠæŸäº›è§£é‡Šè¯´NSArray/NSMutableArray NSDictionary/NSMutableDictionaryåªæœ‰æµ…å¤åˆ¶ï¼Œè¿™é‡Œè®¤ä¸ºå¯¹äºå¯¹è±¡æœ¬èº«æ¥è¯´è°ƒç”¨mutableCopyæˆ–å¯¹äºå¯å˜å¯¹è±¡è°ƒç”¨copyéƒ½æ˜¯æ·±å¤åˆ¶ï¼Œåªèƒ½è¯´å¯¹äºæ•°ç»„å’Œå­—å…¸è¿™ç§å¤åˆç»“æ„æ·±å¤åˆ¶æ“ä½œåªæ˜¯ä½œç”¨åˆ°å¤–å±‚å¯¹è±¡ï¼Œå†…éƒ¨å¦‚æœè¿˜æœ‰å¯å˜å¯¹è±¡ï¼Œä»…ä»…å°±æ˜¯å¼•ç”¨çš„å¤åˆ¶ã€‚ï¼ˆä¸Šé¢çš„ä¾‹å­ä¸­å¯¹äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„æ“ä½œå¯ä»¥å¾ˆæ¸…æ¥šçš„çœ‹å‡ºæ¥ã€‚å³ä½¿æ˜¯å¯¹æ•°ç»„çš„æ·±å¤åˆ¶ï¼Œç„¶è€Œæ”¹å˜ç¬¬ä¸€ä¸ªå¯å˜å­—ç¬¦ä¸²ï¼Œæ— è®ºæ˜¯å‰¯æœ¬æ•°ç»„è¿˜æ˜¯åŸæ•°ç»„çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²éƒ½æ”¹å˜äº†ã€‚ï¼‰ å®Œæ•´ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162//// main.m// CopyDemo//// Created by Jiao Liu on 6/23/16.// Copyright Â© 2016 ChangHong. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;void mutableCopyTest(){ printf(&quot;-----MutableCopy Test-----\\n\\n&quot;); printf(&quot;-NSString Copy-\\n&quot;); NSMutableString *str1 = [NSMutableString stringWithString:@&quot;Hello&quot;]; NSString *str2 = [str1 copy]; [str1 appendString:@&quot; World&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str2 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str2); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str2); printf(&quot;\\n&quot;); NSMutableString *str3 = [str1 mutableCopy]; [str1 appendString:@&quot; + str1&quot;]; [str3 appendString:@&quot; + str3&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str3 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str3); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str3); printf(&quot;\\n&quot;); printf(&quot;-NSArray Copy-\\n&quot;); NSMutableArray *arr1 = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;Hello&quot;], nil]; NSArray *arr2 = [arr1 copy]; [[arr1 objectAtIndex:0] appendString:@&quot; World!&quot;]; [arr1 addObject:@&quot;Word&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr2); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr2); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr2); printf(&quot;\\n&quot;); NSMutableArray *arr3 = [arr1 mutableCopy]; [arr1 addObject:@&quot;+arr1&quot;]; [arr3 addObject:@&quot;+arr3&quot;]; [[arr1 objectAtIndex:0] appendString:@&quot; + str1&quot;]; [[arr3 objectAtIndex:0] appendString:@&quot; + str3&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr3); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr3); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr3); printf(&quot;\\n&quot;);}void constCopyTest(){ printf(&quot;-----ConstCopy Test-----\\n\\n&quot;); printf(&quot;-NSString Copy-\\n&quot;); NSString *str1 = @&quot;Hello&quot;; NSString *str2 = [str1 copy]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str2 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str2); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str2); printf(&quot;\\n&quot;); NSMutableString *str3 = [str1 mutableCopy]; [str3 appendString:@&quot; World!&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str3 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str3); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str3); printf(&quot;\\n&quot;); printf(&quot;-NSArray Copy-\\n&quot;); NSArray *arr1 = [NSArray arrayWithObjects:[NSMutableString stringWithString:@&quot;Hello&quot;], nil]; NSArray *arr2 = [arr1 copy]; [[arr1 objectAtIndex:0] appendString:@&quot; World!&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr2); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr2); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr2); printf(&quot;\\n&quot;); NSMutableArray *arr3 = [arr1 mutableCopy]; [arr3 addObject:@&quot;World&quot;]; [[arr1 objectAtIndex:0] appendString:@&quot; + str1&quot;]; [[arr3 objectAtIndex:0] appendString:@&quot; + str3&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr3); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr3); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr3); printf(&quot;\\n&quot;);}void assignTest(){ printf(&quot;-----Assign Test-----\\n\\n&quot;); NSString *str1 = @&quot;Hello&quot;; NSString *str2 = str1; printf(&quot;orignalStr : %s\\n&quot;,[str1 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str2 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str1); printf(&quot;copyStr value address: %p\\n&quot;,str2); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str1); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str2); printf(&quot;\\n&quot;); NSMutableString *str3 = [NSMutableString stringWithString:@&quot;Hello&quot;]; NSMutableString *str4 = str3; [str3 appendString:@&quot; World&quot;]; [str4 appendString:@&quot;!&quot;]; printf(&quot;orignalStr : %s\\n&quot;,[str3 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;copyStr : %s\\n&quot;,[str4 cStringUsingEncoding:NSUTF8StringEncoding]); printf(&quot;orignalStr value address: %p\\n&quot;,str3); printf(&quot;copyStr value address: %p\\n&quot;,str4); printf(&quot;orignalStr pointer address: %p\\n&quot;,&amp;str3); printf(&quot;copyStr pointer address: %p\\n&quot;,&amp;str4); printf(&quot;\\n&quot;); NSMutableArray *arr1 = [NSMutableArray arrayWithObjects:@&quot;Hello&quot;, nil]; NSMutableArray *arr2 = arr1; [arr1 addObject:@&quot;World&quot;]; [arr2 addObject:@&quot;!&quot;]; NSLog(@&quot;orignalArray : %@&quot;,arr1); NSLog(@&quot;copyArray : %@&quot;,arr2); printf(&quot;orignalArray value address: %p\\n&quot;,arr1); printf(&quot;copyArray value address: %p\\n&quot;,arr2); printf(&quot;orignalArray pointer address: %p\\n&quot;,&amp;arr1); printf(&quot;copyArray pointer address: %p\\n&quot;,&amp;arr2); printf(&quot;\\n&quot;);}int main(int argc, const char * argv[]) { @autoreleasepool { // insert code here... assignTest(); constCopyTest(); mutableCopyTest(); } return 0;} æœ¬æ–‡æœ€æ—©å‘å¸ƒäºé•¿è™¹è½¯æœå…¬ä¼—å·ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥å»çœ‹ä¸€ä¸‹ï¼š å‰–æã€OCã€‘ä¸­æ·±å¤åˆ¶ä¸æµ…å¤åˆ¶","link":"/2016/08/22/å‰–æã€OCã€‘ä¸­æ·±å¤åˆ¶ä¸æµ…å¤åˆ¶/"}],"tags":[{"name":"å°ç†ŠçŒ«","slug":"å°ç†ŠçŒ«","link":"/tags/å°ç†ŠçŒ«/"},{"name":"æ‹›è´¢","slug":"æ‹›è´¢","link":"/tags/æ‹›è´¢/"},{"name":"æ–°ç”Ÿ","slug":"æ–°ç”Ÿ","link":"/tags/æ–°ç”Ÿ/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","link":"/tags/ç®—æ³•/"},{"name":"ç§»åŠ¨ç«¯","slug":"ç§»åŠ¨ç«¯","link":"/tags/ç§»åŠ¨ç«¯/"},{"name":"æœºå™¨å­¦ä¹ ","slug":"æœºå™¨å­¦ä¹ ","link":"/tags/æœºå™¨å­¦ä¹ /"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"},{"name":"å°ç¨‹åº","slug":"å°ç¨‹åº","link":"/tags/å°ç¨‹åº/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"å‰ç«¯","slug":"å‰ç«¯","link":"/tags/å‰ç«¯/"},{"name":"GCJ","slug":"GCJ","link":"/tags/GCJ/"}],"categories":[{"name":"ç”Ÿæ´»","slug":"ç”Ÿæ´»","link":"/categories/ç”Ÿæ´»/"},{"name":"å°ç†ŠçŒ«","slug":"ç”Ÿæ´»/å°ç†ŠçŒ«","link":"/categories/ç”Ÿæ´»/å°ç†ŠçŒ«/"},{"name":"æ‹›è´¢","slug":"ç”Ÿæ´»/æ‹›è´¢","link":"/categories/ç”Ÿæ´»/æ‹›è´¢/"},{"name":"å·¥ä½œ","slug":"å·¥ä½œ","link":"/categories/å·¥ä½œ/"},{"name":"ACM","slug":"å·¥ä½œ/ACM","link":"/categories/å·¥ä½œ/ACM/"},{"name":"iOS","slug":"å·¥ä½œ/iOS","link":"/categories/å·¥ä½œ/iOS/"},{"name":"å°ç¨‹åº","slug":"å·¥ä½œ/å°ç¨‹åº","link":"/categories/å·¥ä½œ/å°ç¨‹åº/"}]}